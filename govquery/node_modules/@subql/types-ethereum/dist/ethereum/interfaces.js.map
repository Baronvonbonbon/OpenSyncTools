{"version":3,"file":"interfaces.js","sourceRoot":"","sources":["../../src/ethereum/interfaces.ts"],"names":[],"mappings":";AAAA,8DAA8D;AAC9D,mCAAmC","sourcesContent":["// Copyright 2020-2025 SubQuery Pte Ltd authors & contributors\n// SPDX-License-Identifier: GPL-3.0\n\nimport {BlockFilter} from '@subql/types-core';\n\nexport type EthereumBlockFilter = BlockFilter;\n\n/**\n * Represents a filter for Ethereum Transactions\n * @interface\n * @extends {EthereumTransactionFilter}\n */\nexport interface EthereumTransactionFilter {\n  /**\n   * The address of sender of the transaction\n   * @example\n   * from: '0x220866B1A2219f40e72f5c628B65D54268cA3A9D',\n   * */\n  from?: string;\n  /**\n   * The to address field within a transaction. This is either the contract address or the recipient if it is an ether transfer.\n   * @example\n   * to: '0x220866B1A2219f40e72f5c628B65D54268cA3A9D',\n   **/\n  to?: string | null;\n  /**\n   * The function sighash or function signature of the call. This is the first 32bytes of the data field\n   * @example\n   * function: 'setminimumStakingAmount(uint256 amount)',\n   * @example\n   * function: null, // This will filter transactions that have no input\n   * @example\n   * function: '0x, // This will filter transactions that have no input\n   * */\n  function?: string | null;\n\n  /**\n   * The transaction type, 0x0 for legacy, 0x1 for access type lists, 0x2 for dynamic fees and 0x3 for blob transactions\n   */\n  type?: `0x${string}`;\n}\n\n/**\n * Represents a filter for Ethereum logs\n * @interface\n * @extends {EthereumLogFilter}\n */\nexport interface EthereumLogFilter {\n  /**\n   * You can filter by the topics in a log.\n   * These can be an address, event signature, null, '!null' or undefined\n   * @example\n   * topics: ['Transfer(address, address, uint256)'],\n   * @example\n   * topics: ['Transfer(address, address, uint256)', undefined, '0x220866B1A2219f40e72f5c628B65D54268cA3A9D']\n   */\n  topics?: Array<string | null | undefined>;\n}\n\nexport interface EthereumResult extends ReadonlyArray<any> {\n  readonly [key: string]: any;\n}\n\nexport type EthereumBlock = {\n  blockExtraData: string;\n  difficulty: bigint;\n  extDataGasUsed: string;\n  extDataHash: string;\n  gasLimit: bigint;\n  gasUsed: bigint;\n  hash: string;\n  logs: EthereumLog[];\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: number;\n  parentHash: string;\n  receiptsRoot: string;\n  sha3Uncles: string;\n  size: bigint;\n  stateRoot: string;\n  timestamp: bigint;\n  totalDifficulty: bigint;\n  transactions: EthereumTransaction[];\n  transactionsRoot: string;\n  uncles: string[];\n  baseFeePerGas?: bigint;\n  blockGasCost?: bigint;\n\n  blobGasUsed?: bigint;\n  excessBlobGas?: bigint;\n};\n\nexport type EthereumTransaction<T extends EthereumResult = EthereumResult> = {\n  blockHash: string;\n  blockNumber: number;\n  blockTimestamp: bigint;\n  from: string;\n  gas: bigint;\n  gasPrice: bigint;\n  hash: string;\n  input: string;\n  nonce: bigint;\n  to?: string;\n  transactionIndex: bigint;\n  value: bigint;\n  type: string;\n  v: bigint;\n  r: string;\n  s: string;\n  /**\n   * @return {EthereumReceipt} This return type is generic because some networks may return more fields such as OP based networks. This allows your to override the type easily\n   **/\n  receipt: <R extends EthereumReceipt = EthereumReceipt>() => Promise<R>;\n  logs?: EthereumLog[];\n  accessList?: string[];\n  chainId?: string; // Hex string , example: \"0x1\"\n  maxFeePerGas?: bigint;\n  maxPriorityFeePerGas?: bigint;\n  args?: T;\n\n  blobVersionedHashes?: string[];\n  maxFeePerBlobGas?: bigint;\n};\n\nexport type EthereumReceipt = {\n  blockHash: string;\n  blockNumber: number;\n  contractAddress: string;\n  cumulativeGasUsed: bigint;\n  effectiveGasPrice: bigint;\n  from: string;\n  gasUsed: bigint;\n  logs: EthereumLog[];\n  logsBloom: string;\n  status: boolean;\n  to: string;\n  transactionHash: string;\n  transactionIndex: number;\n  type: string;\n};\n\nexport type EthereumLog<T extends EthereumResult = EthereumResult> = {\n  address: string;\n  topics: string[];\n  data: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionHash: string;\n  transactionIndex: number;\n  logIndex: number;\n  removed: boolean;\n  args?: T;\n  block: EthereumBlock;\n  transaction: EthereumTransaction;\n};\n\nexport type LightEthereumLog<T extends EthereumResult = EthereumResult> = Omit<\n  EthereumLog<T>,\n  'transaction' | 'block'\n> & {\n  block: LightEthereumBlock;\n};\n\nexport type LightEthereumBlock = Omit<EthereumBlock, 'transactions' | 'logs'> & {\n  logs: LightEthereumLog[];\n  transactions: string[];\n};\n"]}