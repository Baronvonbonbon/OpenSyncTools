export declare const types = "import { IBinaryReader, IBinaryWriter } from \"./binary\";\nimport { Any } from \"./google/protobuf/any\";\nimport { OfflineSigner } from \"@cosmjs/proto-signing\";\nimport { HttpEndpoint } from \"@cosmjs/tendermint-rpc\";\n\nexport type ProtoMsg = Omit<Any, \"typeUrl\"> & { typeUrl: any };\n\nexport interface IAminoMsg<Amino> {\n  type: any;\n  value: Amino;\n}\n\nexport interface IProtoType {\n  $typeUrl?: any;\n}\n\n/**\n * A type generated by Telescope 1.0.\n */\nexport interface TelescopeGeneratedCodec<\n  T = unknown,\n  SDK = unknown,\n  Amino = unknown\n> {\n  readonly typeUrl: string;\n  readonly aminoType?: string;\n  is?(o: unknown): o is T;\n  isSDK?(o: unknown): o is SDK;\n  isAmino?(o: unknown): o is Amino;\n  encode: (message: T, writer?: IBinaryWriter | any) => IBinaryWriter | any;\n  decode: (input: IBinaryReader | Uint8Array | any, length?: number) => T;\n  fromPartial: (object: any) => T | any;\n  fromJSON?: (object: any) => T | any;\n  toJSON?: (message: T | any) => any;\n  fromSDK?: (sdk: SDK) => T;\n  fromSDKJSON?: (object: any) => SDK;\n  toSDK?: (message: T) => SDK;\n  fromAmino?: (amino: Amino) => T;\n  toAmino?: (message: T) => Amino;\n  fromAminoMsg?: (aminoMsg: IAminoMsg<Amino>) => T;\n  toAminoMsg?: (message: T) => IAminoMsg<Amino>;\n  toProto?: (message: T) => Uint8Array;\n  fromProtoMsg?: (message: ProtoMsg) => T;\n  toProtoMsg?: (message: T) => Any;\n}\n\nexport type TelescopeGeneratedType<\n  T = unknown,\n  SDK = unknown,\n  Amino = unknown\n> = TelescopeGeneratedCodec<T, SDK, Amino>;\n\nexport type GeneratedType = TelescopeGeneratedCodec;\n\n/**\n * Coin defines a token with a denomination and an amount.\n *\n * NOTE: The amount field is an Int which implements the custom method\n * signatures required by gogoproto.\n */\nexport interface Coin {\n  denom: string;\n  amount: string;\n}\n\nexport type EncodeObject = Message<any>;\n\nexport interface Message<T> {\n  typeUrl: string;\n  value: T;\n}\n\nexport interface StdFee {\n  amount: Coin[];\n  gas: string;\n  /** The granter address that is used for paying with feegrants */\n  granter?: string;\n  /** The fee payer address. The payer must have signed the transaction. */\n  payer?: string;\n}\n\nexport interface MsgData {\n  msgType: string;\n  data: Uint8Array;\n}\n\nexport interface Attribute {\n  key: string;\n  value: string;\n  index: boolean;\n}\nexport interface Event {\n  type: string;\n  attributes: Attribute[];\n}\n\n/**\n * The response after successfully broadcasting a transaction.\n * Success or failure refer to the execution result.\n */\nexport interface DeliverTxResponse {\n  height: number;\n  /** The position of the transaction within the block. This is a 0-based index. */\n  txIndex: number;\n  /** Error code. The transaction suceeded if and only if code is 0. */\n  code: number;\n  transactionHash: string;\n  events: Event[];\n  /**\n   * A string-based log document.\n   *\n   * This currently seems to merge attributes of multiple events into one event per type\n   * (https://github.com/tendermint/tendermint/issues/9595). You might want to use the `events`\n   * field instead.\n   */\n  rawLog?: string;\n  /** @deprecated Use `msgResponses` instead. */\n  data?: MsgData[];\n  /**\n   * The message responses of the [TxMsgData](https://github.com/cosmos/cosmos-sdk/blob/v0.46.3/proto/cosmos/base/abci/v1beta1/abci.proto#L128-L140)\n   * as `Any`s.\n   * This field is an empty list for chains running Cosmos SDK < 0.46.\n   */\n  msgResponses: Array<{\n    typeUrl: string;\n    value: Uint8Array;\n  }>;\n  gasUsed: bigint;\n  gasWanted: bigint;\n}\n\nexport interface TxRpc {\n  request(\n    service: string,\n    method: string,\n    data: Uint8Array\n  ): Promise<Uint8Array>;\n  signAndBroadcast?(\n    signerAddress: string,\n    messages: EncodeObject[],\n    fee: StdFee | \"auto\" | number,\n    memo: string\n  ): Promise<DeliverTxResponse>;\n}\n\nexport interface SigningClientParams {\n  rpcEndpoint: string | HttpEndpoint;\n  signer: OfflineSigner;\n}\n";
