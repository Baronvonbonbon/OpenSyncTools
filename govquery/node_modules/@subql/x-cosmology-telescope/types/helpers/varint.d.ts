export declare const varint = "\n// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */\n\n/**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [1]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */\nexport function varint64read(this: ReaderLike): [number, number] {\n  let lowBits = 0;\n  let highBits = 0;\n\n  for (let shift = 0; shift < 28; shift += 7) {\n    let b = this.buf[this.pos++];\n    lowBits |= (b & 0x7f) << shift;\n    if ((b & 0x80) == 0) {\n      this.assertBounds();\n      return [lowBits, highBits];\n    }\n  }\n\n  let middleByte = this.buf[this.pos++];\n\n  // last four bits of the first 32 bit number\n  lowBits |= (middleByte & 0x0f) << 28;\n\n  // 3 upper bits are part of the next 32 bit number\n  highBits = (middleByte & 0x70) >> 4;\n\n  if ((middleByte & 0x80) == 0) {\n    this.assertBounds();\n    return [lowBits, highBits];\n  }\n\n  for (let shift = 3; shift <= 31; shift += 7) {\n    let b = this.buf[this.pos++];\n    highBits |= (b & 0x7f) << shift;\n    if ((b & 0x80) == 0) {\n      this.assertBounds();\n      return [lowBits, highBits];\n    }\n  }\n\n  throw new Error(\"invalid varint\");\n}\n\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */\nexport function varint64write(lo: number, hi: number, bytes: number[]): void {\n  for (let i = 0; i < 28; i = i + 7) {\n    const shift = lo >>> i;\n    const hasNext = !(shift >>> 7 == 0 && hi == 0);\n    const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n    bytes.push(byte);\n    if (!hasNext) {\n      return;\n    }\n  }\n\n  const splitBits = ((lo >>> 28) & 0x0f) | ((hi & 0x07) << 4);\n  const hasMoreBits = !(hi >> 3 == 0);\n  bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\n\n  if (!hasMoreBits) {\n    return;\n  }\n\n  for (let i = 3; i < 31; i = i + 7) {\n    const shift = hi >>> i;\n    const hasNext = !(shift >>> 7 == 0);\n    const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n    bytes.push(byte);\n    if (!hasNext) {\n      return;\n    }\n  }\n\n  bytes.push((hi >>> 31) & 0x01);\n}\n\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\n\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nexport function int64FromString(dec: string): { lo: number; hi: number } {\n  // Check for minus sign.\n  const minus = dec[0] === \"-\";\n  if (minus) {\n    dec = dec.slice(1);\n  }\n\n  // Work 6 decimal digits at a time, acting like we're converting base 1e6\n  // digits to binary. This is safe to do with floating point math because\n  // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n  const base = 1e6;\n  let lowBits = 0;\n  let highBits = 0;\n\n  function add1e6digit(begin: number, end?: number) {\n    // Note: Number('') is 0.\n    const digit1e6 = Number(dec.slice(begin, end));\n    highBits *= base;\n    lowBits = lowBits * base + digit1e6;\n    // Carry bits from lowBits to\n    if (lowBits >= TWO_PWR_32_DBL) {\n      highBits = highBits + ((lowBits / TWO_PWR_32_DBL) | 0);\n      lowBits = lowBits % TWO_PWR_32_DBL;\n    }\n  }\n\n  add1e6digit(-24, -18);\n  add1e6digit(-18, -12);\n  add1e6digit(-12, -6);\n  add1e6digit(-6);\n  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n}\n\n/**\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nexport function int64ToString(lo: number, hi: number): string {\n  let bits = newBits(lo, hi);\n  // If we're treating the input as a signed value and the high bit is set, do\n  // a manual two's complement conversion before the decimal conversion.\n  const negative = bits.hi & 0x80000000;\n  if (negative) {\n    bits = negate(bits.lo, bits.hi);\n  }\n  const result = uInt64ToString(bits.lo, bits.hi);\n  return negative ? \"-\" + result : result;\n}\n\n/**\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nexport function uInt64ToString(lo: number, hi: number): string {\n  ({ lo, hi } = toUnsigned(lo, hi));\n  // Skip the expensive conversion if the number is small enough to use the\n  // built-in conversions.\n  // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\n  // highBits <= 0x1FFFFF can be safely expressed with a double and retain\n  // integer precision.\n  // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\n  if (hi <= 0x1fffff) {\n    return String(TWO_PWR_32_DBL * hi + lo);\n  }\n\n  // What this code is doing is essentially converting the input number from\n  // base-2 to base-1e7, which allows us to represent the 64-bit range with\n  // only 3 (very large) digits. Those digits are then trivial to convert to\n  // a base-10 string.\n\n  // The magic numbers used here are -\n  // 2^24 = 16777216 = (1,6777216) in base-1e7.\n  // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n\n  // Split 32:32 representation into 16:24:24 representation so our\n  // intermediate digits don't overflow.\n  const low = lo & 0xffffff;\n  const mid = ((lo >>> 24) | (hi << 8)) & 0xffffff;\n  const high = (hi >> 16) & 0xffff;\n\n  // Assemble our three base-1e7 digits, ignoring carries. The maximum\n  // value in a digit at this step is representable as a 48-bit integer, which\n  // can be stored in a 64-bit floating point number.\n  let digitA = low + mid * 6777216 + high * 6710656;\n  let digitB = mid + high * 8147497;\n  let digitC = high * 2;\n\n  // Apply carries from A to B and from B to C.\n  const base = 10000000;\n  if (digitA >= base) {\n    digitB += Math.floor(digitA / base);\n    digitA %= base;\n  }\n\n  if (digitB >= base) {\n    digitC += Math.floor(digitB / base);\n    digitB %= base;\n  }\n\n  // If digitC is 0, then we should have returned in the trivial code path\n  // at the top for non-safe integers. Given this, we can assume both digitB\n  // and digitA need leading zeros.\n  return (\n    digitC.toString() +\n    decimalFrom1e7WithLeadingZeros(digitB) +\n    decimalFrom1e7WithLeadingZeros(digitA)\n  );\n}\n\nfunction toUnsigned(lo: number, hi: number): { lo: number; hi: number } {\n  return { lo: lo >>> 0, hi: hi >>> 0 };\n}\n\nfunction newBits(lo: number, hi: number): { lo: number; hi: number } {\n  return { lo: lo | 0, hi: hi | 0 };\n}\n\n/**\n * Returns two's compliment negation of input.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n */\nfunction negate(lowBits: number, highBits: number) {\n  highBits = ~highBits;\n  if (lowBits) {\n    lowBits = ~lowBits + 1;\n  } else {\n    // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\n    // adding 1 to that, results in 0x100000000, which leaves\n    // the low bits 0x0 and simply adds one to the high bits.\n    highBits += 1;\n  }\n  return newBits(lowBits, highBits);\n}\n\n/**\n * Returns decimal representation of digit1e7 with leading zeros.\n */\nconst decimalFrom1e7WithLeadingZeros = (digit1e7: number) => {\n  const partial = String(digit1e7);\n  return \"0000000\".slice(partial.length) + partial;\n};\n\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */\nexport function varint32write(value: number, bytes: number[]): void {\n  if (value >= 0) {\n    // write value as varint 32\n    while (value > 0x7f) {\n      bytes.push((value & 0x7f) | 0x80);\n      value = value >>> 7;\n    }\n    bytes.push(value);\n  } else {\n    for (let i = 0; i < 9; i++) {\n      bytes.push((value & 127) | 128);\n      value = value >> 7;\n    }\n    bytes.push(1);\n  }\n}\n\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */\nexport function varint32read(this: ReaderLike): number {\n  let b = this.buf[this.pos++];\n  let result = b & 0x7f;\n  if ((b & 0x80) == 0) {\n    this.assertBounds();\n    return result;\n  }\n\n  b = this.buf[this.pos++];\n  result |= (b & 0x7f) << 7;\n  if ((b & 0x80) == 0) {\n    this.assertBounds();\n    return result;\n  }\n\n  b = this.buf[this.pos++];\n  result |= (b & 0x7f) << 14;\n  if ((b & 0x80) == 0) {\n    this.assertBounds();\n    return result;\n  }\n\n  b = this.buf[this.pos++];\n  result |= (b & 0x7f) << 21;\n  if ((b & 0x80) == 0) {\n    this.assertBounds();\n    return result;\n  }\n\n  // Extract only last 4 bits\n  b = this.buf[this.pos++];\n  result |= (b & 0x0f) << 28;\n\n  for (let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)\n    b = this.buf[this.pos++];\n\n  if ((b & 0x80) != 0) throw new Error(\"invalid varint\");\n\n  this.assertBounds();\n\n  // Result can have 32 bits, convert it to unsigned\n  return result >>> 0;\n}\n\ntype ReaderLike = {\n  buf: Uint8Array;\n  pos: number;\n  len: number;\n  assertBounds(): void;\n};\n\n/**\n * encode zig zag\n */\nexport function zzEncode(lo: number, hi: number) {\n  let mask = hi >> 31;\n  hi = (((hi << 1) | (lo >>> 31)) ^ mask) >>> 0;\n  lo = ((lo << 1) ^ mask) >>> 0;\n  return [lo, hi];\n}\n\n/**\n * decode zig zag\n */\nexport function zzDecode(lo: number, hi: number) {\n  let mask = -(lo & 1);\n  lo = (((lo >>> 1) | (hi << 31)) ^ mask) >>> 0;\n  hi = ((hi >>> 1) ^ mask) >>> 0;\n  return [lo, hi];\n}\n\n/**\n * unsigned int32 without moving pos.\n */\nexport function readUInt32(buf: Uint8Array, pos: number) {\n  return (\n    (buf[pos] | (buf[pos + 1] << 8) | (buf[pos + 2] << 16)) +\n    buf[pos + 3] * 0x1000000\n  );\n}\n\n/**\n * signed int32 without moving pos.\n */\nexport function readInt32(buf: Uint8Array, pos: number) {\n  return (\n    (buf[pos] | (buf[pos + 1] << 8) | (buf[pos + 2] << 16)) +\n    (buf[pos + 3] << 24)\n  );\n}\n\n/**\n * writing varint32 to pos\n */\nexport function writeVarint32(\n  val: number,\n  buf: Uint8Array | number[],\n  pos: number\n) {\n  while (val > 127) {\n    buf[pos++] = (val & 127) | 128;\n    val >>>= 7;\n  }\n  buf[pos] = val;\n}\n\n/**\n * writing varint64 to pos\n */\nexport function writeVarint64(\n  val: { lo: number; hi: number },\n  buf: Uint8Array | number[],\n  pos: number\n) {\n  while (val.hi) {\n    buf[pos++] = (val.lo & 127) | 128;\n    val.lo = ((val.lo >>> 7) | (val.hi << 25)) >>> 0;\n    val.hi >>>= 7;\n  }\n  while (val.lo > 127) {\n    buf[pos++] = (val.lo & 127) | 128;\n    val.lo = val.lo >>> 7;\n  }\n  buf[pos++] = val.lo;\n}\n\nexport function int64Length(lo: number, hi: number) {\n  let part0 = lo,\n    part1 = ((lo >>> 28) | (hi << 4)) >>> 0,\n    part2 = hi >>> 24;\n  return part2 === 0\n    ? part1 === 0\n      ? part0 < 16384\n        ? part0 < 128\n          ? 1\n          : 2\n        : part0 < 2097152\n        ? 3\n        : 4\n      : part1 < 16384\n      ? part1 < 128\n        ? 5\n        : 6\n      : part1 < 2097152\n      ? 7\n      : 8\n    : part2 < 128\n    ? 9\n    : 10;\n}\n\nexport function writeFixed32(\n  val: number,\n  buf: Uint8Array | number[],\n  pos: number\n) {\n  buf[pos] = val & 255;\n  buf[pos + 1] = (val >>> 8) & 255;\n  buf[pos + 2] = (val >>> 16) & 255;\n  buf[pos + 3] = val >>> 24;\n}\n\nexport function writeByte(\n  val: number,\n  buf: Uint8Array | number[],\n  pos: number\n) {\n  buf[pos] = val & 255;\n}\n";
