export declare const binary = "\n// Copyright (c) 2016, Daniel Wirtz  All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n\n// * Redistributions of source code must retain the above copyright\n//   notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n// * Neither the name of its author, nor the names of its contributors\n//   may be used to endorse or promote products derived from this software\n//   without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// ---\n\n// Code generated by the command line utilities is owned by the owner\n// of the input file used when generating it. This code is not\n// standalone and requires a support library to be linked with it. This\n// support library is itself covered by the above license.\n\nimport { utf8Length, utf8Read, utf8Write } from \"./utf8\";\nimport {\n  int64ToString,\n  readInt32,\n  readUInt32,\n  uInt64ToString,\n  varint32read,\n  varint64read,\n  writeVarint32,\n  writeVarint64,\n  int64FromString,\n  int64Length,\n  writeFixed32,\n  writeByte,\n  zzDecode,\n  zzEncode,\n} from \"./varint\";\n\nexport enum WireType {\n  Varint = 0,\n\n  Fixed64 = 1,\n\n  Bytes = 2,\n\n  Fixed32 = 5,\n}\n\n// Reader\nexport interface IBinaryReader {\n  buf: Uint8Array;\n  pos: number;\n  type: number;\n  len: number;\n  tag(): [number, WireType, number];\n  skip(length?: number): this;\n  skipType(wireType: number): this;\n  uint32(): number;\n  int32(): number;\n  sint32(): number;\n  fixed32(): number;\n  sfixed32(): number;\n  int64(): bigint;\n  uint64(): bigint;\n  sint64(): bigint;\n  fixed64(): bigint;\n  sfixed64(): bigint;\n  float(): number;\n  double(): number;\n  bool(): boolean;\n  bytes(): Uint8Array;\n  string(): string;\n}\n\nexport class BinaryReader implements IBinaryReader {\n  buf: Uint8Array;\n  pos: number;\n  type: number;\n  len: number;\n\n  assertBounds(): void {\n    if (this.pos > this.len) throw new RangeError(\"premature EOF\");\n  }\n\n  constructor(buf?: ArrayLike<number>) {\n    this.buf = buf ? new Uint8Array(buf) : new Uint8Array(0);\n    this.pos = 0;\n    this.type = 0;\n    this.len = this.buf.length;\n  }\n\n  tag(): [number, WireType, number] {\n    const tag = this.uint32(),\n      fieldNo = tag >>> 3,\n      wireType = tag & 7;\n    if (fieldNo <= 0 || wireType < 0 || wireType > 5)\n      throw new Error(\n        \"illegal tag: field no \" + fieldNo + \" wire type \" + wireType\n      );\n    return [fieldNo, wireType, tag];\n  }\n\n  skip(length?: number) {\n    if (typeof length === \"number\") {\n      if (this.pos + length > this.len) throw indexOutOfRange(this, length);\n      this.pos += length;\n    } else {\n      do {\n        if (this.pos >= this.len) throw indexOutOfRange(this);\n      } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n  }\n\n  skipType(wireType: number) {\n    switch (wireType) {\n      case WireType.Varint:\n        this.skip();\n        break;\n      case WireType.Fixed64:\n        this.skip(8);\n        break;\n      case WireType.Bytes:\n        this.skip(this.uint32());\n        break;\n      case 3:\n        while ((wireType = this.uint32() & 7) !== 4) {\n          this.skipType(wireType);\n        }\n        break;\n      case WireType.Fixed32:\n        this.skip(4);\n        break;\n\n      /* istanbul ignore next */\n      default:\n        throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n  }\n\n  uint32(): number {\n    return varint32read.bind(this)();\n  }\n\n  int32(): number {\n    return this.uint32() | 0;\n  }\n\n  sint32(): number {\n    const num = this.uint32();\n    return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding\n  }\n\n  fixed32(): number {\n    const val = readUInt32(this.buf, this.pos);\n    this.pos += 4;\n    return val;\n  }\n\n  sfixed32(): number {\n    const val = readInt32(this.buf, this.pos);\n    this.pos += 4;\n    return val;\n  }\n\n  int64(): bigint {\n    const [lo, hi] = varint64read.bind(this)();\n    return BigInt(int64ToString(lo, hi));\n  }\n\n  uint64(): bigint {\n    const [lo, hi] = varint64read.bind(this)();\n    return BigInt(uInt64ToString(lo, hi));\n  }\n\n  sint64(): bigint {\n    let [lo, hi] = varint64read.bind(this)();\n    // zig zag\n    [lo, hi] = zzDecode(lo, hi);\n    return BigInt(int64ToString(lo, hi));\n  }\n\n  fixed64(): bigint {\n    const lo = this.sfixed32();\n    const hi = this.sfixed32();\n    return BigInt(uInt64ToString(lo, hi));\n  }\n  sfixed64(): bigint {\n    const lo = this.sfixed32();\n    const hi = this.sfixed32();\n    return BigInt(int64ToString(lo, hi));\n  }\n\n  float(): number {\n    throw new Error(\"float not supported\");\n  }\n\n  double(): number {\n    throw new Error(\"double not supported\");\n  }\n\n  bool(): boolean {\n    const [lo, hi] = varint64read.bind(this)();\n    return lo !== 0 || hi !== 0;\n  }\n\n  bytes(): Uint8Array {\n    const len = this.uint32(),\n      start = this.pos;\n    this.pos += len;\n    this.assertBounds();\n    return this.buf.subarray(start, start + len);\n  }\n\n  string(): string {\n    const bytes = this.bytes();\n    return utf8Read(bytes, 0, bytes.length);\n  }\n}\n\n// Writer\nexport interface IBinaryWriter {\n  len: number;\n  head: IOp;\n  tail: IOp;\n  states: State | null;\n  finish(): Uint8Array;\n  fork(): IBinaryWriter;\n  reset(): IBinaryWriter;\n  ldelim(): IBinaryWriter;\n  tag(fieldNo: number, type: WireType): IBinaryWriter;\n  uint32(value: number): IBinaryWriter;\n  int32(value: number): IBinaryWriter;\n  sint32(value: number): IBinaryWriter;\n  int64(value: string | number | bigint): IBinaryWriter;\n  uint64: (value: string | number | bigint) => IBinaryWriter;\n  sint64(value: string | number | bigint): IBinaryWriter;\n  fixed64(value: string | number | bigint): IBinaryWriter;\n  sfixed64: (value: string | number | bigint) => IBinaryWriter;\n  bool(value: boolean): IBinaryWriter;\n  fixed32(value: number): IBinaryWriter;\n  sfixed32: (value: number) => IBinaryWriter;\n  float(value: number): IBinaryWriter;\n  double(value: number): IBinaryWriter;\n  bytes(value: Uint8Array): IBinaryWriter;\n  string(value: string): IBinaryWriter;\n}\n\ninterface IOp {\n  len: number;\n  next?: IOp;\n  proceed(buf: Uint8Array | number[], pos: number): void;\n}\n\nclass Op<T> implements IOp {\n  fn?: ((val: T, buf: Uint8Array | number[], pos: number) => void) | null;\n  len: number;\n  val: T;\n  next?: IOp;\n\n  constructor(\n    fn:\n      | ((\n          val: T,\n          buf: Uint8Array | number[],\n          pos: number\n        ) => void | undefined | null)\n      | null,\n    len: number,\n    val: T\n  ) {\n    this.fn = fn;\n    this.len = len;\n    this.val = val;\n  }\n\n  proceed(buf: Uint8Array | number[], pos: number) {\n    if (this.fn) {\n      this.fn(this.val, buf, pos);\n    }\n  }\n}\n\nclass State {\n  head: IOp;\n  tail: IOp;\n  len: number;\n  next: State | null;\n\n  constructor(writer: BinaryWriter) {\n    this.head = writer.head;\n    this.tail = writer.tail;\n    this.len = writer.len;\n    this.next = writer.states;\n  }\n}\n\nexport class BinaryWriter implements IBinaryWriter {\n  len = 0;\n  head: IOp;\n  tail: IOp;\n  states: State | null;\n\n  constructor() {\n    this.head = new Op(null, 0, 0);\n    this.tail = this.head;\n    this.states = null;\n  }\n\n  static create() {\n    return new BinaryWriter();\n  }\n\n  static alloc(size: number): Uint8Array | number[] {\n    if (typeof Uint8Array !== \"undefined\") {\n      return pool(\n        (size) => new Uint8Array(size),\n        Uint8Array.prototype.subarray\n      )(size);\n    } else {\n      return new Array(size);\n    }\n  }\n\n  private _push<T>(\n    fn: (val: T, buf: Uint8Array | number[], pos: number) => void,\n    len: number,\n    val: T\n  ) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n  }\n\n  finish(): Uint8Array {\n    let head = this.head.next,\n      pos = 0;\n    const buf = BinaryWriter.alloc(this.len);\n    while (head) {\n      head.proceed(buf, pos);\n      pos += head.len;\n      head = head.next;\n    }\n    return buf as Uint8Array;\n  }\n\n  fork(): BinaryWriter {\n    this.states = new State(this);\n    this.head = this.tail = new Op(null, 0, 0);\n    this.len = 0;\n    return this;\n  }\n\n  reset(): BinaryWriter {\n    if (this.states) {\n      this.head = this.states.head;\n      this.tail = this.states.tail;\n      this.len = this.states.len;\n      this.states = this.states.next;\n    } else {\n      this.head = this.tail = new Op(null, 0, 0);\n      this.len = 0;\n    }\n    return this;\n  }\n\n  ldelim(): BinaryWriter {\n    const head = this.head,\n      tail = this.tail,\n      len = this.len;\n    this.reset().uint32(len);\n    if (len) {\n      this.tail.next = head.next; // skip noop\n      this.tail = tail;\n      this.len += len;\n    }\n    return this;\n  }\n\n  tag(fieldNo: number, type: WireType): BinaryWriter {\n    return this.uint32(((fieldNo << 3) | type) >>> 0);\n  }\n\n  uint32(value: number): BinaryWriter {\n    this.len += (this.tail = this.tail.next =\n      new Op(\n        writeVarint32,\n        (value = value >>> 0) < 128\n          ? 1\n          : value < 16384\n          ? 2\n          : value < 2097152\n          ? 3\n          : value < 268435456\n          ? 4\n          : 5,\n        value\n      )).len;\n    return this;\n  }\n\n  int32(value: number): BinaryWriter {\n    return value < 0\n      ? this._push(writeVarint64, 10, int64FromString(value.toString())) // 10 bytes per spec\n      : this.uint32(value);\n  }\n\n  sint32(value: number): BinaryWriter {\n    return this.uint32(((value << 1) ^ (value >> 31)) >>> 0);\n  }\n\n  int64(value: string | number | bigint): BinaryWriter {\n    const { lo, hi } = int64FromString(value.toString());\n    return this._push(writeVarint64, int64Length(lo, hi), { lo, hi });\n  }\n\n  // uint64 is the same with int64\n  uint64 = BinaryWriter.prototype.int64;\n\n  sint64(value: string | number | bigint): BinaryWriter {\n    let { lo, hi } = int64FromString(value.toString());\n    // zig zag\n    [lo, hi] = zzEncode(lo, hi);\n    return this._push(writeVarint64, int64Length(lo, hi), { lo, hi });\n  }\n\n  fixed64(value: string | number | bigint): BinaryWriter {\n    const { lo, hi } = int64FromString(value.toString());\n    return this._push(writeFixed32, 4, lo)._push(writeFixed32, 4, hi);\n  }\n\n  // sfixed64 is the same with fixed64\n  sfixed64 = BinaryWriter.prototype.fixed64;\n\n  bool(value: boolean): BinaryWriter {\n    return this._push(writeByte, 1, value ? 1 : 0);\n  }\n\n  fixed32(value: number): BinaryWriter {\n    return this._push(writeFixed32, 4, value >>> 0);\n  }\n\n  // sfixed32 is the same with fixed32\n  sfixed32 = BinaryWriter.prototype.fixed32;\n\n  float(value: number): BinaryWriter {\n    throw new Error(\"float not supported\" + value);\n  }\n\n  double(value: number): BinaryWriter {\n    throw new Error(\"double not supported\" + value);\n  }\n\n  bytes(value: Uint8Array): BinaryWriter {\n    const len = value.length >>> 0;\n    if (!len) return this._push(writeByte, 1, 0);\n    return this.uint32(len)._push(writeBytes, len, value);\n  }\n\n  string(value: string): BinaryWriter {\n    const len = utf8Length(value);\n    return len\n      ? this.uint32(len)._push(utf8Write, len, value)\n      : this._push(writeByte, 1, 0);\n  }\n}\n\nfunction writeBytes(\n  val: Uint8Array | number[],\n  buf: Uint8Array | number[],\n  pos: number\n) {\n  if (typeof Uint8Array !== \"undefined\") {\n    (buf as Uint8Array).set(val, pos);\n  } else {\n    for (let i = 0; i < val.length; ++i) buf[pos + i] = val[i];\n  }\n}\n\nfunction pool(\n  alloc: (size: number) => Uint8Array,\n  slice: (begin?: number, end?: number) => Uint8Array,\n  size?: number\n): (size: number) => Uint8Array {\n  const SIZE = size || 8192;\n  const MAX = SIZE >>> 1;\n  let slab: Uint8Array | null = null;\n  let offset = SIZE;\n  return function pool_alloc(size): Uint8Array {\n    if (size < 1 || size > MAX) return alloc(size);\n    if (offset + size > SIZE) {\n      slab = alloc(SIZE);\n      offset = 0;\n    }\n    const buf: Uint8Array = slice.call(slab, offset, (offset += size));\n    if (offset & 7)\n      // align to 32 bit\n      offset = (offset | 7) + 1;\n    return buf;\n  };\n}\n\nfunction indexOutOfRange(reader: BinaryReader, writeLength?: number) {\n  return RangeError(\n    \"index out of range: \" +\n      reader.pos +\n      \" + \" +\n      (writeLength || 1) +\n      \" > \" +\n      reader.len\n  );\n}\n";
