export declare const utf8 = "\n// Copyright (c) 2016, Daniel Wirtz  All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n\n// * Redistributions of source code must retain the above copyright\n//   notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n// * Neither the name of its author, nor the names of its contributors\n//   may be used to endorse or promote products derived from this software\n//   without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\"use strict\";\n\n/**\n * Calculates the UTF8 byte length of a string.\n * @param {string} string String\n * @returns {number} Byte length\n */\nexport function utf8Length(str: string) {\n  let len = 0,\n    c = 0;\n  for (let i = 0; i < str.length; ++i) {\n    c = str.charCodeAt(i);\n    if (c < 128) len += 1;\n    else if (c < 2048) len += 2;\n    else if (\n      (c & 0xfc00) === 0xd800 &&\n      (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00\n    ) {\n      ++i;\n      len += 4;\n    } else len += 3;\n  }\n  return len;\n}\n\n/**\n * Reads UTF8 bytes as a string.\n * @param {Uint8Array} buffer Source buffer\n * @param {number} start Source start\n * @param {number} end Source end\n * @returns {string} String read\n */\nexport function utf8Read(\n  buffer: ArrayLike<number>,\n  start: number,\n  end: number\n) {\n  const len = end - start;\n  if (len < 1) return \"\";\n  const chunk = [];\n  let parts: string[] = [],\n    i = 0, // char offset\n    t; // temporary\n  while (start < end) {\n    t = buffer[start++];\n    if (t < 128) chunk[i++] = t;\n    else if (t > 191 && t < 224)\n      chunk[i++] = ((t & 31) << 6) | (buffer[start++] & 63);\n    else if (t > 239 && t < 365) {\n      t =\n        (((t & 7) << 18) |\n          ((buffer[start++] & 63) << 12) |\n          ((buffer[start++] & 63) << 6) |\n          (buffer[start++] & 63)) -\n        0x10000;\n      chunk[i++] = 0xd800 + (t >> 10);\n      chunk[i++] = 0xdc00 + (t & 1023);\n    } else\n      chunk[i++] =\n        ((t & 15) << 12) |\n        ((buffer[start++] & 63) << 6) |\n        (buffer[start++] & 63);\n    if (i > 8191) {\n      (parts || (parts = [])).push(String.fromCharCode(...chunk));\n      i = 0;\n    }\n  }\n  if (parts) {\n    if (i) parts.push(String.fromCharCode(...chunk.slice(0, i)));\n    return parts.join(\"\");\n  }\n  return String.fromCharCode(...chunk.slice(0, i));\n}\n\n/**\n * Writes a string as UTF8 bytes.\n * @param {string} string Source string\n * @param {Uint8Array} buffer Destination buffer\n * @param {number} offset Destination offset\n * @returns {number} Bytes written\n */\nexport function utf8Write(\n  str: string,\n  buffer: Uint8Array | Array<number>,\n  offset: number\n) {\n  const start = offset;\n  let c1, // character 1\n    c2; // character 2\n  for (let i = 0; i < str.length; ++i) {\n    c1 = str.charCodeAt(i);\n    if (c1 < 128) {\n      buffer[offset++] = c1;\n    } else if (c1 < 2048) {\n      buffer[offset++] = (c1 >> 6) | 192;\n      buffer[offset++] = (c1 & 63) | 128;\n    } else if (\n      (c1 & 0xfc00) === 0xd800 &&\n      ((c2 = str.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n    ) {\n      c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n      ++i;\n      buffer[offset++] = (c1 >> 18) | 240;\n      buffer[offset++] = ((c1 >> 12) & 63) | 128;\n      buffer[offset++] = ((c1 >> 6) & 63) | 128;\n      buffer[offset++] = (c1 & 63) | 128;\n    } else {\n      buffer[offset++] = (c1 >> 12) | 224;\n      buffer[offset++] = ((c1 >> 6) & 63) | 128;\n      buffer[offset++] = (c1 & 63) | 128;\n    }\n  }\n  return offset - start;\n}\n";
