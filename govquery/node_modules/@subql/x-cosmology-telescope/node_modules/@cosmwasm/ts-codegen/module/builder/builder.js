import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { defaultOptions, BuilderContext } from "wasm-ast-types";
import { header } from '../utils/header';
import { join } from "path";
import { writeFileSync } from 'fs';
import { sync as mkdirp } from "mkdirp";
import { basename } from 'path';
import { readSchemas } from '../utils';
import deepmerge from 'deepmerge';
import { pascal } from "case";
import { createFileBundle, recursiveModuleBundle } from "../bundler";
import generate from '@babel/generator';
import * as t from '@babel/types';
import { ReactQueryPlugin } from "../plugins/react-query";
import { RecoilPlugin } from "../plugins/recoil";
import { MsgBuilderPlugin } from "../plugins/msg-builder";
import { MessageComposerPlugin } from "../plugins/message-composer";
import { ClientPlugin } from "../plugins/client";
import { TypesPlugin } from "../plugins/types";
import { ContractsContextProviderPlugin } from "../plugins/provider";
import { createHelpers } from "../generators/create-helpers";
import { ContractsProviderBundlePlugin } from "../plugins/provider-bundle";
const defaultOpts = {
  bundle: {
    enabled: true,
    scope: 'contracts',
    bundleFile: 'bundle.ts'
  }
};
;
;
;
;

function getContract(contractOpt) {
  if (typeof contractOpt === 'string') {
    const name = basename(contractOpt);
    const contractName = pascal(name);
    return {
      name: contractName,
      dir: contractOpt
    };
  }

  return {
    name: pascal(contractOpt.name),
    dir: contractOpt.dir
  };
}

export class TSBuilder {
  loadDefaultPlugins() {
    [].push.apply(this.plugins, [new TypesPlugin(this.options), new ClientPlugin(this.options), new MessageComposerPlugin(this.options), new ReactQueryPlugin(this.options), new RecoilPlugin(this.options), new MsgBuilderPlugin(this.options), new ContractsContextProviderPlugin(this.options)]);
  }

  constructor({
    contracts,
    outPath,
    options,
    plugins
  }) {
    _defineProperty(this, "contracts", void 0);

    _defineProperty(this, "outPath", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "plugins", []);

    _defineProperty(this, "builderContext", new BuilderContext());

    _defineProperty(this, "files", []);

    this.contracts = contracts;
    this.outPath = outPath;
    this.options = deepmerge(deepmerge(defaultOptions, defaultOpts), options ?? {});
    this.loadDefaultPlugins();

    if (plugins && plugins.length) {
      [].push.apply(this.plugins, plugins);
    }

    this.plugins.forEach(plugin => plugin.setBuilder(this));
  }

  async build() {
    await this.process();
    await this.after();
  } // lifecycle functions


  async process() {
    for (const contractOpt of this.contracts) {
      const contract = getContract(contractOpt); //resolve contract schema.

      const contractInfo = await readSchemas({
        schemaDir: contract.dir
      }); //lifecycle and plugins.

      await this.render(contract.name, contractInfo);
    }
  }

  async render(name, contractInfo) {
    for (const plugin of this.plugins) {
      let files = await plugin.render(name, contractInfo, this.outPath);

      if (files && files.length) {
        [].push.apply(this.files, files);
      }
    }
  }

  async after() {
    //create useContracts bundle file
    const contractsProviderBundlePlugin = new ContractsProviderBundlePlugin(this.options);
    contractsProviderBundlePlugin.setBuilder(this); //contractContextProviders.ts

    const files = await contractsProviderBundlePlugin.render("contractContextProviders", {
      schemas: []
    }, this.outPath);

    if (files && files.length) {
      [].push.apply(this.files, files);
    }

    const helpers = createHelpers({
      outPath: this.outPath,
      contracts: this.contracts,
      options: this.options,
      plugins: this.plugins
    }, this.builderContext);

    if (helpers && helpers.length) {
      [].push.apply(this.files, helpers);
    }

    if (this.options.bundle.enabled) {
      this.bundle();
    }
  }

  async bundle() {
    const allFiles = this.files;
    const bundleFile = this.options.bundle.bundleFile;
    const bundlePath = join(this.options?.bundle?.bundlePath ?? this.outPath, bundleFile);
    const bundleVariables = {};
    const importPaths = [];
    allFiles.forEach(file => {
      createFileBundle(`${this.options.bundle.scope}.${file.contract}`, file.filename, bundlePath, importPaths, bundleVariables);
    });
    const ast = recursiveModuleBundle(bundleVariables);
    let code = generate(t.program([...importPaths, ...ast])).code;

    if (this.options?.bundle?.bundlePath) {
      mkdirp(this.options?.bundle?.bundlePath);
    }

    mkdirp(this.outPath);
    if (code.trim() === '') code = 'export {};';
    writeFileSync(bundlePath, header + code);
  }

}