{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/project/utils.ts"],"names":[],"mappings":";AAAA,8DAA8D;AAC9D,mCAAmC;;;;;;AA0BnC,0DAIC;AAED,0DAIC;AAED,wDAIC;AAED,gCAIC;AAED,kCAEC;AAED,gEAOC;AAED,gEAcC;AAED,0CAUC;AAvFD,gDAAwB;AACxB,0CAAiD;AACjD,0DAU+B;AAC/B,+CAAqD;AACrD,qDAA+F;AAC/F,4CAA2C;AAE3C,wGAAwG;AAC3F,QAAA,eAAe,GAAG,OAAO,CAAC;AAE1B,QAAA,eAAe,GAAG,OAAO,CAAC;AAIvC,SAAgB,uBAAuB,CACrC,EAAiF;IAEjF,OAAO,EAAE,CAAC,eAAe,KAAK,oCAAmB,CAAC,KAAK,CAAC;AAC1D,CAAC;AAED,SAAgB,uBAAuB,CACrC,EAAiF;IAEjF,OAAO,EAAE,CAAC,eAAe,KAAK,oCAAmB,CAAC,KAAK,CAAC;AAC1D,CAAC;AAED,SAAgB,sBAAsB,CACpC,EAAiF;IAEjF,OAAO,EAAE,CAAC,eAAe,KAAK,oCAAmB,CAAC,IAAI,CAAC;AACzD,CAAC;AAED,SAAgB,UAAU,CACxB,EAAmB;IAEnB,OAAO,EAAE,CAAC,IAAI,KAAK,uCAAsB,CAAC,OAAO,IAAI,CAAC,CAAE,EAAoC,CAAC,SAAS,CAAC;AACzG,CAAC;AAED,SAAgB,WAAW,CAAC,EAAmB;IAC7C,OAAO,EAAE,CAAC,IAAI,KAAK,uCAAsB,CAAC,OAAO,CAAC;AACpD,CAAC;AAED,SAAgB,0BAA0B,CAAC,OAAe;IACxD,IAAI,CAAC;QACH,MAAM,SAAS,GAAG,IAAA,0BAAiB,EAAC,OAAO,CAAC,CAAC;QAC7C,OAAO,IAAA,mCAAiB,EAAC,SAAS,CAAC,CAAC;IACtC,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QACX,OAAO,IAAA,mCAAiB,EAAC,OAAO,CAAC,CAAC;IACpC,CAAC;AACH,CAAC;AAED,SAAgB,0BAA0B,CAAC,iBAAqC;IAC9E,OAAO,IAAA,4BAAU,EACf;QACE,IAAI,EAAE,4BAA4B;QAClC,SAAS,EAAE;YACT,QAAQ,EAAE,CAAC,KAAK,EAAE,IAAI,EAAW,EAAE,CAAC,0BAA0B,CAAC,KAAK,CAAC;YACrE,cAAc,EAAE,IAAA,8BAAY,EAC1B,CAAC,UAAU,EAAE,EAAE,CAAC,GAAG,UAAU,qCAAqC,EAClE,iBAAiB,CAClB;SACF;KACF,EACD,iBAAiB,CAClB,CAAC;AACJ,CAAC;AAED,SAAgB,eAAe,CAAC,WAAmB,EAAE,WAAmB;IACtE,MAAM,GAAG,GAAG,IAAA,2BAAkB,EAAC,cAAI,CAAC,IAAI,CAAC,WAAW,EAAE,uBAAe,EAAE,WAAW,CAAC,CAAQ,CAAC;IAC5F,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;QACxB,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC;YACb,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC,CAAC;QACjE,CAAC;QACD,OAAO,IAAI,iBAAS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAChC,CAAC;SAAM,CAAC;QACN,OAAO,IAAI,iBAAS,CAAC,GAAG,CAAC,CAAC;IAC5B,CAAC;AACH,CAAC","sourcesContent":["// Copyright 2020-2025 SubQuery Pte Ltd authors & contributors\n// SPDX-License-Identifier: GPL-3.0\n\nimport path from 'path';\nimport {loadFromJsonOrYaml} from '@subql/common';\nimport {\n  SecondLayerHandlerProcessor,\n  SubqlCustomDatasource,\n  SubqlDatasource,\n  EthereumDatasourceKind,\n  EthereumHandlerKind,\n  SubqlRuntimeDatasource,\n  SecondLayerHandlerProcessorArray,\n  SubqlCustomHandler,\n  SubqlMapping,\n} from '@subql/types-ethereum';\nimport {fromBech32Address} from '@zilliqa-js/crypto';\nimport {buildMessage, isEthereumAddress, ValidateBy, ValidationOptions} from 'class-validator';\nimport {Interface} from 'ethers/lib/utils';\n\n// Todo, this aligns with cli/src/generate-controller, but we should move this to common in next version\nexport const DEFAULT_ABI_DIR = '/abis';\n\nexport const NOT_NULL_FILTER = '!null';\n\ntype DefaultFilter = Record<string, unknown>;\n\nexport function isBlockHandlerProcessor<E>(\n  hp: SecondLayerHandlerProcessorArray<EthereumHandlerKind, DefaultFilter, unknown>\n): hp is SecondLayerHandlerProcessor<EthereumHandlerKind.Block, DefaultFilter, E> {\n  return hp.baseHandlerKind === EthereumHandlerKind.Block;\n}\n\nexport function isEventHandlerProcessor<E>(\n  hp: SecondLayerHandlerProcessorArray<EthereumHandlerKind, DefaultFilter, unknown>\n): hp is SecondLayerHandlerProcessor<EthereumHandlerKind.Event, DefaultFilter, E> {\n  return hp.baseHandlerKind === EthereumHandlerKind.Event;\n}\n\nexport function isCallHandlerProcessor<E>(\n  hp: SecondLayerHandlerProcessorArray<EthereumHandlerKind, DefaultFilter, unknown>\n): hp is SecondLayerHandlerProcessor<EthereumHandlerKind.Call, DefaultFilter, E> {\n  return hp.baseHandlerKind === EthereumHandlerKind.Call;\n}\n\nexport function isCustomDs<F extends SubqlMapping<SubqlCustomHandler>>(\n  ds: SubqlDatasource\n): ds is SubqlCustomDatasource<string, F> {\n  return ds.kind !== EthereumDatasourceKind.Runtime && !!(ds as SubqlCustomDatasource<string>).processor;\n}\n\nexport function isRuntimeDs(ds: SubqlDatasource): ds is SubqlRuntimeDatasource {\n  return ds.kind === EthereumDatasourceKind.Runtime;\n}\n\nexport function isEthereumOrZilliqaAddress(address: string): boolean {\n  try {\n    const ethFormat = fromBech32Address(address);\n    return isEthereumAddress(ethFormat);\n  } catch (e) {\n    return isEthereumAddress(address);\n  }\n}\n\nexport function IsEthereumOrZilliqaAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n  return ValidateBy(\n    {\n      name: 'isEthereumOrZilliqaAddress',\n      validator: {\n        validate: (value, args): boolean => isEthereumOrZilliqaAddress(value),\n        defaultMessage: buildMessage(\n          (eachPrefix) => `${eachPrefix}$property must be a Zilliqa address`,\n          validationOptions\n        ),\n      },\n    },\n    validationOptions\n  );\n}\n\nexport function getAbiInterface(projectPath: string, abiFileName: string): Interface {\n  const abi = loadFromJsonOrYaml(path.join(projectPath, DEFAULT_ABI_DIR, abiFileName)) as any;\n  if (!Array.isArray(abi)) {\n    if (!abi.abi) {\n      throw new Error(`Provided ABI is not a valid ABI or Artifact`);\n    }\n    return new Interface(abi.abi);\n  } else {\n    return new Interface(abi);\n  }\n}\n"]}