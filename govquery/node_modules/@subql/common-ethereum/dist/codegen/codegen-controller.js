"use strict";
// Copyright 2020-2025 SubQuery Pte Ltd authors & contributors
// SPDX-License-Identifier: GPL-3.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.joinInputAbiName = joinInputAbiName;
exports.prepareSortedAssets = prepareSortedAssets;
exports.prepareAbiJob = prepareAbiJob;
exports.getAbiNames = getAbiNames;
exports.generateAbis = generateAbis;
const assert_1 = __importDefault(require("assert"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const abi_1 = require("@ethersproject/abi");
const types_ethereum_1 = require("@subql/types-ethereum");
const typechain_1 = require("typechain");
const project_1 = require("../project");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const RECONSTRUCTED_FACTORIES_TS = path_1.default.resolve(__dirname, '../../templates/factories-index.ts.ejs');
const RECONSTRUCTED_CONTRACTS_TS = path_1.default.resolve(__dirname, '../../templates/contracts-index.ts.ejs');
const ABI_INTERFACE_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../../templates/abi-interface.ts.ejs');
const ABI_INTERFACES_ROOT_DIR = 'src/types/abi-interfaces';
const CONTRACTS_DIR = 'src/types/contracts'; //generated
const FACTORIES_DIR = path_1.default.join(CONTRACTS_DIR, 'factories'); // generated
const TYPECHAIN_TARGET = 'ethers-v5';
function validateCustomDsDs(d) {
    return constants_1.CUSTOM_EVM_HANDLERS.includes(d.kind);
}
function validateAbi(datasources, projectPath) {
    const issues = [];
    for (const datasource of datasources) {
        if (!datasource.options?.abi) {
            // No ABI to validate
            continue;
        }
        const abiName = datasource.options.abi;
        const topicIssues = [];
        const funcIssues = [];
        let data = '';
        try {
            const abi = datasource.assets?.get(abiName);
            if (!abi) {
                issues.push(`Asset: "${abiName}" not found in project`);
                continue;
            }
            data = fs_1.default.readFileSync(path_1.default.join(projectPath, abi.file), 'utf8');
        }
        catch (e) {
            issues.push(`Asset: "${abiName}" not found in project`);
            continue;
        }
        let abiObj = JSON.parse(data);
        if (!Array.isArray(abiObj) && abiObj.abi) {
            abiObj = abiObj.abi;
        }
        const iface = new abi_1.Interface(abiObj);
        const abiFunctions = Object.values(iface.functions).map((func) => func.format());
        const abiEvents = Object.values(iface.events).map((event) => event.format());
        for (const mappingHandler of datasource.mapping.handlers) {
            if (!mappingHandler?.filter)
                continue;
            if (mappingHandler.kind === types_ethereum_1.EthereumHandlerKind.Event) {
                if (!mappingHandler.filter.topics || !mappingHandler.filter.topics.length)
                    continue;
                const notMatch = mappingHandler.filter.topics.find((topic) => topic && topic !== project_1.NOT_NULL_FILTER && !abiEvents.includes(abi_1.EventFragment.fromString(topic).format()));
                if (notMatch)
                    topicIssues.push(notMatch);
            }
            if (mappingHandler.kind === types_ethereum_1.EthereumHandlerKind.Call) {
                if (!mappingHandler.filter.function)
                    continue;
                const functionFormat = abi_1.FunctionFragment.fromString(mappingHandler.filter.function).format();
                if (!abiFunctions.includes(functionFormat))
                    funcIssues.push(mappingHandler.filter.function);
            }
        }
        if (topicIssues.length) {
            issues.push(`Topic: "${topicIssues.join(', ')}" not found in ${abiName} contract interface, supported topics: ${abiEvents.join(', ')}`);
        }
        if (funcIssues.length) {
            issues.push(`Function: "${funcIssues.join(', ')}" not found in ${abiName} contract interface, supported functions: ${abiFunctions.join(', ')}`);
        }
    }
    (0, assert_1.default)(issues.length === 0, issues.join('\n'));
}
function joinInputAbiName(abiObject) {
    // example: "TextChanged_bytes32_string_string_string_Event", Event name/Function type name will be joined in ejs
    const inputToSnake = abiObject.inputs.map((obj) => obj.type.replace(/\[\]/g, '_arr').toLowerCase()).join('_');
    return `${abiObject.name}_${inputToSnake}_`;
}
function inputsToArgs(inputs) {
    const args = inputs
        .map((input) => {
        if (input.components) {
            const inner = inputsToArgs(input.components);
            if (input.type === 'tuple[]') {
                return `${inner}[]`;
            }
            return inner;
        }
        return input.type.toLowerCase();
    })
        .join(',');
    return `(${args})`;
}
function prepareSortedAssets(datasources, projectPath) {
    const sortedAssets = {};
    const addAsset = (name, value) => {
        // should do if covert to absolute
        // if value.file is not absolute, the
        const filePath = path_1.default.join(projectPath, value.file);
        if (!fs_1.default.existsSync(filePath)) {
            throw new Error(`Error: Asset ${name}, file ${value.file} does not exist`);
        }
        // We use actual abi file name instead on name provided in assets
        // This is aligning with files in './ethers-contracts'
        sortedAssets[(0, typechain_1.parseContractPath)(filePath).name] = value.file;
    };
    for (const d of datasources) {
        if (!d.assets)
            continue;
        if (!(0, project_1.isRuntimeDs)(d) && !(0, project_1.isCustomDs)(d) && !validateCustomDsDs(d))
            continue;
        for (const [name, value] of d.assets.entries()) {
            addAsset(name, value);
        }
    }
    return sortedAssets;
}
// maybe refactor to use fragments ? ( can do that after the v6 migrate
function prepareAbiJob(sortedAssets, projectPath, loadReadAbi) {
    const renderInterfaceJobs = [];
    Object.entries(sortedAssets).forEach(([key, value]) => {
        const renderProps = { name: key, events: [], functions: [] };
        const readAbi = loadReadAbi(path_1.default.join(projectPath, value));
        // We need to use for loop instead of map, due to events/function name could be duplicate,
        // because they have different input, and following ether typegen rules, name also changed
        // we need to find duplicates, and update its name rather than just unify them.
        let abiArray = [];
        if (!Array.isArray(readAbi)) {
            if (!readAbi.abi) {
                throw new Error(`Provided ABI is not a valid ABI or Artifact`);
            }
            abiArray = readAbi.abi;
        }
        else {
            abiArray = readAbi;
        }
        if (!abiArray.length) {
            throw new Error(`Invalid abi is provided at asset: ${key}, ${value}, ${abiArray.length}`);
        }
        const duplicateEventNames = abiArray
            .filter((abiObject) => abiObject.type === 'event')
            .map((obj) => obj.name)
            .filter((name, index, arr) => arr.indexOf(name) !== index);
        const duplicateFunctionNames = abiArray
            .filter((abiObject) => abiObject.type === 'function')
            .map((obj) => obj.name)
            .filter((name, index, arr) => arr.indexOf(name) !== index);
        abiArray.map((abiObject) => {
            if (abiObject.type === 'function') {
                let typeName = abiObject.name;
                let functionName = abiObject.name;
                if (duplicateFunctionNames.includes(abiObject.name)) {
                    functionName = `${abiObject.name}${inputsToArgs(abiObject.inputs)}`;
                    typeName = joinInputAbiName(abiObject);
                }
                renderProps.functions.push({ typeName, functionName });
            }
            if (abiObject.type === 'event') {
                let name = abiObject.name;
                if (duplicateEventNames.includes(abiObject.name)) {
                    name = joinInputAbiName(abiObject);
                }
                renderProps.events.push(name);
            }
        });
        // avoid empty json
        if (!!renderProps.events || !!renderProps.functions) {
            renderInterfaceJobs.push(renderProps);
        }
    });
    return renderInterfaceJobs;
}
function getAbiNames(files) {
    return files
        .filter((filename) => filename !== 'index.ts')
        .map((fileName) => path_1.default.parse(fileName).name.replace('__factory', ''));
}
async function generateAbis(datasources, projectPath, prepareDirPath, upperFirst, renderTemplate) {
    // @subql/cli package calls this function with datasources as an array of objects
    datasources = datasources.map((d) => ({
        ...d,
        assets: d?.assets ? (d.assets instanceof Map ? d.assets : new Map(Object.entries(d.assets))) : undefined,
    }));
    validateAbi(datasources, projectPath);
    const sortedAssets = prepareSortedAssets(datasources, projectPath);
    if (Object.keys(sortedAssets).length === 0) {
        return prepareDirPath(path_1.default.join(projectPath, ABI_INTERFACES_ROOT_DIR), false);
    }
    await prepareDirPath(path_1.default.join(projectPath, ABI_INTERFACES_ROOT_DIR), true);
    try {
        const allFiles = (0, typechain_1.glob)(projectPath, Object.values(sortedAssets));
        // Typechain generate interfaces under CONTRACTS_DIR
        // Run typechain for individual paths, if provided glob paths are the same,
        // it will generate incorrect file structures, and fail to generate contracts for certain abis
        await Promise.all(allFiles.map((file) => (0, typechain_1.runTypeChain)({
            cwd: projectPath,
            filesToProcess: [file],
            allFiles: [file],
            outDir: CONTRACTS_DIR,
            target: TYPECHAIN_TARGET,
        })));
        const factoryFiles = fs_1.default.readdirSync(path_1.default.join(projectPath, FACTORIES_DIR));
        const abiNames = getAbiNames(factoryFiles);
        // factories index
        await Promise.all([
            // Restructure factories/index.ts
            renderTemplate(RECONSTRUCTED_FACTORIES_TS, path_1.default.join(projectPath, FACTORIES_DIR, 'index.ts'), {
                props: { abiNames },
            }),
            // Restructure contracts/index.ts
            renderTemplate(RECONSTRUCTED_CONTRACTS_TS, path_1.default.join(projectPath, CONTRACTS_DIR, 'index.ts'), {
                props: { abiNames },
            }),
        ]);
        // Iterate here as we have to make sure type chain generated successful,
        // also avoid duplicate generate same abi interfaces
        const renderAbiJobs = prepareAbiJob(sortedAssets, projectPath, utils_1.loadReadAbi);
        await Promise.all(renderAbiJobs.map((renderProps) => {
            console.log(`* Abi Interface ${renderProps.name} generated`);
            return renderTemplate(ABI_INTERFACE_TEMPLATE_PATH, path_1.default.join(projectPath, ABI_INTERFACES_ROOT_DIR, `${renderProps.name}.ts`), {
                props: { abi: renderProps },
                helper: { upperFirst },
            });
        }));
    }
    catch (e) {
        console.error(`! Unable to generate abi interface. ${e.message}`);
    }
}
//# sourceMappingURL=codegen-controller.js.map