{"version":3,"file":"project.js","sourceRoot":"","sources":["../src/project.ts"],"names":[],"mappings":";AAAA,iEAAiE;AACjE,mCAAmC;;;AA4CnC,IAAY,oBAGX;AAHD,WAAY,oBAAoB;IAC9B,kDAA0B,CAAA;IAC1B,gDAAwB,CAAA;AAC1B,CAAC,EAHW,oBAAoB,oCAApB,oBAAoB,QAG/B;AAED;;;GAGG;AACH,IAAY,iBAiBX;AAjBD,WAAY,iBAAiB;IAC3B;;OAEG;IACH,kDAA6B,CAAA;IAC7B;;OAEG;IACH,8DAAyC,CAAA;IACzC;;OAEG;IACH,sDAAiC,CAAA;IACjC;;OAEG;IACH,kDAA6B,CAAA;AAC/B,CAAC,EAjBW,iBAAiB,iCAAjB,iBAAiB,QAiB5B","sourcesContent":["// // Copyright 2020-2025 SubQuery Pte Ltd authors & contributors\n// SPDX-License-Identifier: GPL-3.0\n\nimport {CosmWasmClient} from '@cosmjs/cosmwasm-stargate';\nimport {Registry} from '@cosmjs/proto-signing';\nimport {\n  BaseTemplateDataSource,\n  IProjectNetworkConfig,\n  CommonSubqueryProject,\n  FileReference,\n  Processor,\n  ProjectManifestV1_0_0,\n  BlockFilter,\n  BaseHandler,\n  BaseMapping,\n  BaseDataSource,\n  BaseCustomDataSource,\n  SecondLayerHandlerProcessor_0_0_0,\n  SecondLayerHandlerProcessor_1_0_0,\n  DsProcessor,\n} from '@subql/types-core';\nimport {CosmosBlock, CosmosTransaction, CosmosMessage, CosmosEvent} from './interfaces';\n\nexport type RuntimeDatasourceTemplate = BaseTemplateDataSource<CosmosRuntimeDatasource>;\nexport type CustomDatasourceTemplate = BaseTemplateDataSource<CosmosCustomDatasource>;\n\nexport type CosmosProjectManifestV1_0_0 = ProjectManifestV1_0_0<\n  CosmosRuntimeDatasource | CosmosCustomDatasource,\n  RuntimeDatasourceTemplate | CustomDatasourceTemplate,\n  CosmosNetworkConfig\n>;\n\nexport interface CustomModule extends FileReference {\n  /**\n   * The messages within the file to import\n   * @example\n   * messages: [\"MsgEthereumTx\", \"LegacyTx\", \"AccessListTx\". \"DynamicFeeTx\"],\n   * */\n  messages: string[];\n}\n\nexport type CosmosChaintypes = Map<string, CustomModule>;\n\nexport type CustomDataSourceAsset = FileReference;\n\nexport enum CosmosDatasourceKind {\n  Runtime = 'cosmos/Runtime',\n  Custom = 'cosmos/Custom',\n}\n\n/**\n * Enum representing the kind of Cosmos handler.\n * @enum {string}\n */\nexport enum CosmosHandlerKind {\n  /**\n   * Handler for Cosmos blocks.\n   */\n  Block = 'cosmos/BlockHandler',\n  /**\n   * Handler for Cosmos transactions.\n   */\n  Transaction = 'cosmos/TransactionHandler',\n  /**\n   * Handler for Cosmos messages.\n   */\n  Message = 'cosmos/MessageHandler',\n  /**\n   * Handler for Cosmos events.\n   */\n  Event = 'cosmos/EventHandler',\n}\n\nexport type CosmosRuntimeHandlerInputMap = {\n  [CosmosHandlerKind.Block]: CosmosBlock;\n  [CosmosHandlerKind.Transaction]: CosmosTransaction;\n  [CosmosHandlerKind.Message]: CosmosMessage;\n  [CosmosHandlerKind.Event]: CosmosEvent;\n};\n\ntype CosmosRuntimeFilterMap = {\n  [CosmosHandlerKind.Block]: CosmosBlockFilter;\n  [CosmosHandlerKind.Transaction]: CosmosTxFilter;\n  [CosmosHandlerKind.Message]: CosmosMessageFilter;\n  [CosmosHandlerKind.Event]: CosmosEventFilter;\n};\n\n/**\n * Represents a Cosmos subquery network configuration, which is based on the CommonSubqueryNetworkConfig template.\n * @type {IProjectNetworkConfig}\n */\nexport type CosmosNetworkConfig = IProjectNetworkConfig & {\n  /**\n   * Messages custom to the chain that will need to be decoded.\n   * If filters do not pick up these message types they don't need to be added.\n   * The key needs to be a unique value, it's good to have the same key as the package but if there are multiple files with the same package then change the name.\n   * @example\n   * chaintypes: {\n      ethermint.evm.v1: {\n        file: \"./proto/ethermint/evm/v1/tx.proto\",\n        messages: [\n          \"MsgEthereumTx\",\n          \"LegacyTx\",\n          \"AccessListTx\",\n          \"DynamicFeeTx\",\n        ]\n      }\n    }\n   * */\n  chaintypes?: CosmosChaintypes;\n};\n\nexport type CosmosBlockFilter = BlockFilter;\n\nexport interface CosmosTxFilter {\n  /**\n   * Filter in failed transactions\n   * @example\n   * includeFailedTx: true,\n   * */\n  includeFailedTx?: boolean;\n}\n\n/**\n * Represents a filter for Cosmos messages, extending CosmosTxFilter.\n * @interface\n * @extends {CosmosTxFilter}\n */\nexport interface CosmosMessageFilter extends CosmosTxFilter {\n  /**\n   * The type of message, this matches the protobuf message descriptor\n   * @example\n   * type: \"/cosmwasm.wasm.v1.MsgExecuteContract\",\n   * */\n  type: string;\n  contractCall?: string;\n  /**\n   * Filter by the arguments to the message\n   * @example\n   * values: {\n      contract: \"juno128lewlw6kv223uw4yzdffl8rnh3k9qs8vrf6kef28579w8ygccyq7m90n2\"\n     }\n   */\n  values?: {\n    [key: string]: string;\n  };\n}\n\n/**\n * Represents a filter for Cosmos events.\n * @interface\n * @extends {CosmosEventFilter}\n */\nexport interface CosmosEventFilter {\n  /**\n   * The type of the event\n   * @example\n   * type: 'wasm',\n   * */\n  type: string;\n  /**\n   * A message filter to filter events from a message\n   * @example\n   * messageFilter: {\n       type: \"/cosmwasm.wasm.v1.MsgExecuteContract\"\n       values: {\n         contract: \"juno128lewlw6kv223uw4yzdffl8rnh3k9qs8vrf6kef28579w8ygccyq7m90n2\"\n       }\n     }\n   * */\n  messageFilter?: CosmosMessageFilter;\n  /**\n   * Attributes of the event to filter by\n   * */\n  attributes?: Record<string, string | number>;\n}\n\nexport type CosmosHandlerFilter = CosmosEventFilter | CosmosMessageFilter;\n\n/**\n * Represents a handler for Cosmos blocks.\n * @type {CosmosCustomHandler<CosmosHandlerKind.Block, CosmosBlockFilter>}\n */\nexport type CosmosBlockHandler = CosmosCustomHandler<CosmosHandlerKind.Block, CosmosBlockFilter>;\n/**\n * Represents a handler for Cosmos transactions.\n * @type {CosmosCustomHandler<CosmosHandlerKind.Transaction, CosmosTxFilter>}\n */\nexport type CosmosTransactionHandler = CosmosCustomHandler<CosmosHandlerKind.Transaction, CosmosTxFilter>;\n/**\n * Represents a handler for Cosmos messages.\n * @type {CosmosCustomHandler<CosmosHandlerKind.Message, CosmosMessageFilter>}\n */\nexport type CosmosMessageHandler = CosmosCustomHandler<CosmosHandlerKind.Message, CosmosMessageFilter>;\n/**\n * Represents a handler for Cosmos events.\n * @type {CosmosCustomHandler<CosmosHandlerKind.Event, CosmosEventFilter>}\n */\nexport type CosmosEventHandler = CosmosCustomHandler<CosmosHandlerKind.Event, CosmosEventFilter>;\n\n/**\n * Represents a generic custom handler for Cosmos.\n * @interface\n * @template K - The kind of the handler (default: string).\n * @template F - The filter type for the handler (default: Record<string, unknown>).\n */\nexport interface CosmosCustomHandler<K extends string = string, F = Record<string, unknown>> extends BaseHandler<F, K> {\n  /**\n   * The kind of handler. For `cosmos/Runtime` datasources this is either `Block`, `Transaction`, `Message` or `Event` kinds.\n   * The value of this will determine the filter options as well as the data provided to your handler function\n   * @type {CosmosHandlerKind.Block | CosmosHandlerKind.Transaction | CosmosHandlerKind.Message | CosmosHandlerKind.Event | string }\n   * @example\n   * kind: CosmosHandlerKind.Block // Defined with an enum, this is used for runtime datasources\n   * @example\n   * kind: 'cosmos/EthermintEvmEvent' // Defined with a string, this is used with custom datasources\n   */\n  kind: K;\n  /**\n   * The filter for the handler. The handler kind will determine the possible filters (optional).\n   *\n   * @type {F}\n   */\n  filter?: F;\n}\n\n/**\n * Represents a runtime handler for Cosmos, which can be a block handler, transaction handler, message handler, or event handler.\n * @type {CosmosBlockHandler | CosmosTransactionHandler | CosmosMessageHandler | CosmosEventHandler}\n */\nexport type CosmosRuntimeHandler =\n  | CosmosBlockHandler\n  | CosmosTransactionHandler\n  | CosmosMessageHandler\n  | CosmosEventHandler;\n\nexport type CosmosHandler = CosmosRuntimeHandler | CosmosCustomHandler;\n\n/**\n * Represents a mapping for Cosmos handlers, extending FileReference.\n * @interface\n * @extends {FileReference}\n */\nexport interface CosmosMapping<T extends CosmosHandler = CosmosHandler> extends BaseMapping<T> {\n  /**\n   * An array of handlers associated with the mapping.\n   * @type {T[]}\n   * @example\n   * handlers: [{\n        kind: CosmosHandlerKind.Call,\n        handler: 'handleCall',\n        filter: {\n          type: \"/cosmwasm.wasm.v1.MsgExecuteContract\"\n        }\n      }]\n   */\n  handlers: T[];\n}\n\n/**\n * Represents a Cosmos datasource interface with generic parameters.\n * @interface\n * @template M - The mapping type for the datasource.\n */\ntype ICosmosDatasource<M extends CosmosMapping> = BaseDataSource<CosmosHandler, M>;\n\nexport interface SubqlCosmosProcessorOptions {\n  /**\n   * The name of the ABI referenced in assets to be used with this datasource\n   * This is used for codegen with cosmwasm\n   * @example\n   * api: 'cw20',\n   * */\n  abi?: string;\n}\n\n/**\n * Represents a runtime datasource for Cosmos.\n * @interface\n * @template M - The mapping type for the datasource (default: CosmosMapping<CosmosRuntimeHandler>).\n */\nexport interface CosmosRuntimeDatasource<\n  M extends CosmosMapping<CosmosRuntimeHandler> = CosmosMapping<CosmosRuntimeHandler>\n> extends ICosmosDatasource<M> {\n  /**\n   * The kind of the datasource, which is `cosmos/Runtime`.\n   * @type {CosmosDatasourceKind.Runtime}\n   */\n  kind: CosmosDatasourceKind.Runtime;\n  /**\n   * Options for this datasource, this includes the abi if its a cosmwasm datasource\n   * @type {SubqlCosmosProcessorOptions}\n   * */\n  options?: SubqlCosmosProcessorOptions;\n  /**\n   * Assets used by this datasource, these can be used in options.abi\n   * @example\n   * assets: {cw20: {file: './cosmwasm-contract/cw20/schema/cw20.json'}}\n   * */\n  assets?: Map<string, FileReference>;\n}\n\n/**\n * Represents a Cosmos datasource, which can be either runtime or custom.\n * @type {CosmosDatasource}\n */\nexport type CosmosDatasource = CosmosRuntimeDatasource | CosmosCustomDatasource;\n\nexport type CustomCosmosDataSourceAsset = FileReference;\n\n/**\n * Represents a custom datasource for Cosmos.\n * @interface\n * @template K - The kind of the datasource (default: string).\n * @template M - The mapping type for the datasource (default: CosmosMapping<CosmosCustomHandler>).\n * @template O - The processor options (default: any).\n */\nexport interface CosmosCustomDatasource<\n  K extends string = string,\n  M extends CosmosMapping = CosmosMapping<CosmosCustomHandler>,\n  O = any\n> extends BaseCustomDataSource<CosmosHandler, M> {\n  /**\n   * The kind of the custom datasource. This should follow the pattern `cosmos/*`.\n   * @type {K}\n   * @example\n   * kind: 'cosmos/EthermintEvm'\n   */\n  kind: K;\n  /**\n   * The processor used for the custom datasource.\n   * @type {Processor<O>}\n   * @example\n   * processor: {\n   *    file: './node_modules/@subql/ethermint-evm-processor/dist/bundle.js',\n   *    options: {\n   *      abi: 'erc20',\n   *      address: '0x322E86852e492a7Ee17f28a78c663da38FB33bfb',\n   *    }\n   *  }\n   */\n  processor: Processor<O>;\n}\n\nexport interface HandlerInputTransformer_0_0_0<\n  T extends CosmosHandlerKind,\n  E,\n  DS extends CosmosCustomDatasource = CosmosCustomDatasource\n> {\n  (input: CosmosRuntimeHandlerInputMap[T], ds: DS, api: CosmWasmClient, assets?: Record<string, string>): Promise<E>;\n}\n\nexport interface HandlerInputTransformer_1_0_0<\n  T extends CosmosHandlerKind,\n  F,\n  E,\n  DS extends CosmosCustomDatasource = CosmosCustomDatasource\n> {\n  (params: {\n    input: CosmosRuntimeHandlerInputMap[T];\n    ds: DS;\n    filter?: F;\n    api: CosmWasmClient;\n    assets?: Record<string, string>;\n  }): Promise<E[]>;\n}\n\nexport type SecondLayerHandlerProcessor<\n  K extends CosmosHandlerKind,\n  F extends Record<string, unknown>, // EthereumRuntimeFilterMap?\n  E,\n  DS extends CosmosCustomDatasource = CosmosCustomDatasource\n> =\n  | SecondLayerHandlerProcessor_0_0_0<K, CosmosRuntimeHandlerInputMap, CosmosRuntimeFilterMap, F, E, DS, CosmWasmClient>\n  | (SecondLayerHandlerProcessor_1_0_0<\n      K,\n      CosmosRuntimeHandlerInputMap,\n      CosmosRuntimeFilterMap,\n      F,\n      E,\n      DS,\n      CosmWasmClient\n    > & {\n      // Overwrite the function to include registry\n      filterProcessor: (params: {\n        filter: F | undefined;\n        input: CosmosRuntimeHandlerInputMap[K];\n        ds: DS;\n        registry: Registry;\n      }) => boolean;\n    });\n\nexport type SecondLayerHandlerProcessorArray<\n  K extends string,\n  F extends Record<string, unknown>,\n  T,\n  DS extends CosmosCustomDatasource<K> = CosmosCustomDatasource<K>\n> =\n  | SecondLayerHandlerProcessor<CosmosHandlerKind.Block, F, T, DS>\n  | SecondLayerHandlerProcessor<CosmosHandlerKind.Transaction, F, T, DS>\n  | SecondLayerHandlerProcessor<CosmosHandlerKind.Message, F, T, DS>\n  | SecondLayerHandlerProcessor<CosmosHandlerKind.Event, F, T, DS>;\n\nexport type CosmosDatasourceProcessor<\n  K extends string,\n  F extends Record<string, unknown>,\n  DS extends CosmosCustomDatasource<K> = CosmosCustomDatasource<K>,\n  P extends Record<string, SecondLayerHandlerProcessorArray<K, F, any, DS>> = Record<\n    string,\n    SecondLayerHandlerProcessorArray<K, F, any, DS>\n  >\n> = DsProcessor<DS, P, CosmWasmClient>;\n\n/**\n * Represents a Cosmos project configuration based on the CommonSubqueryProject template.\n */\nexport type CosmosProject<DS extends CosmosDatasource = CosmosRuntimeDatasource> = CommonSubqueryProject<\n  CosmosNetworkConfig,\n  CosmosRuntimeDatasource | DS,\n  BaseTemplateDataSource<CosmosRuntimeDatasource> | BaseTemplateDataSource<DS>\n>;\n"]}