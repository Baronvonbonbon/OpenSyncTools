"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.recursiveTraversal = exports.traverse = exports.parseFullyTraversedProtoImports = exports.symbolsToImportNames = exports.TraverseContext = void 0;
const x_cosmology_ast_1 = require("@subql/x-cosmology-ast");
const protobufjs_1 = require("@cosmology/protobufjs");
const lookup_1 = require("./lookup");
const services_1 = require("./services");
const utils_1 = require("./utils");
class TraverseContext {
    constructor(store, ref) {
        this.store = store;
        this.ref = ref;
        this.acceptsInterface = {};
        this.implementsInterface = {};
        this.imports = {};
        this.exports = {};
    }
    addImport(filename, symbolName) {
        this.imports[filename] = this.imports[filename] || [];
        this.imports[filename] = [...new Set([...this.imports[filename], symbolName])];
    }
    addImplements(symbolName, msgName) {
        this.implementsInterface = this.implementsInterface || {};
        this.implementsInterface[symbolName] = this.implementsInterface[symbolName] || [];
        this.implementsInterface[symbolName] = [...new Set([...this.implementsInterface[symbolName], msgName])];
    }
    addAccepts(symbolName, msgName) {
        this.acceptsInterface[symbolName] = this.acceptsInterface[symbolName] || [];
        this.acceptsInterface[symbolName] = [...new Set([...this.acceptsInterface[symbolName], msgName])];
    }
    addExport(symbolName) {
        this.exports[symbolName] = true;
    }
}
exports.TraverseContext = TraverseContext;
const symbolsToImportNames = (ref, symbols) => {
    return symbols.reduce((m, v) => {
        // imports to self... nope.
        if (v.source === ref.filename)
            return m;
        m[v.source] = m[v.source] || {};
        m[v.source][v.symbolName] = v.readAs;
        return m;
    }, {});
};
exports.symbolsToImportNames = symbolsToImportNames;
const parseFullyTraversedProtoImports = (store, actualFiles) => {
    const protos = store.getProtos();
    const records = [];
    const symbols = [];
    // AGGREGATE ALL implements
    protos.forEach(ref => {
        const enabled = (0, x_cosmology_ast_1.getPluginValue)('interfaces.enabled', ref.proto.package, store.options);
        if (!enabled)
            return;
        if (actualFiles && !actualFiles.has(ref.filename)) {
            return;
        }
        //
        const implementsInterface = ref.traversed?.implementsInterface ?? {};
        Object.keys(implementsInterface).forEach(implementsType => {
            implementsInterface[implementsType].forEach(msgName => {
                records.push({
                    filename: ref.filename,
                    implementsType,
                    msgName
                });
            });
        });
    });
    protos.forEach(ref => {
        if (actualFiles && !actualFiles.has(ref.filename)) {
            return;
        }
        const localSymbols = [];
        const hasConflict = (symbolName) => {
            return localSymbols.filter(a => a.symbolName === symbolName).length > 1;
        };
        const findAvailableName = (symbolName) => {
            let counter = 1;
            if (!hasConflict(symbolName))
                return symbolName;
            while (true) {
                const testName = symbolName + counter;
                const found = localSymbols.find(a => a.readAs === testName);
                if (found) {
                    counter++;
                }
                else {
                    return testName;
                }
            }
        };
        Object.keys(ref.traversed?.parsedExports ?? {}).forEach(e => {
            localSymbols.push({
                type: 'export',
                source: ref.filename,
                symbolName: e,
                readAs: e
            });
        });
        Object.keys(ref.traversed?.parsedImports ?? {}).forEach(source => {
            const imps = ref.traversed?.parsedImports?.[source] ?? [];
            imps.forEach(im => {
                localSymbols.push({
                    type: 'import',
                    source,
                    symbolName: im,
                    readAs: im
                });
            });
        });
        Object.keys(ref.traversed?.acceptsInterface ?? {}).forEach(implementsType => {
            const enabled = (0, x_cosmology_ast_1.getPluginValue)('interfaces.enabled', ref.proto.package, store.options);
            if (!enabled)
                return;
            const recordsThatMatter = records.filter(rec => rec.implementsType === implementsType);
            const notYetInImports = recordsThatMatter.filter(r => {
                return !localSymbols.find(l => l.source === r.filename && l.symbolName === r.msgName);
            });
            const alreadyInImports = recordsThatMatter.filter(r => {
                return localSymbols.find(l => l.source === r.filename && l.symbolName === r.msgName);
            });
            notYetInImports.forEach(imp => {
                localSymbols.push({
                    type: 'import',
                    source: imp.filename,
                    readAs: imp.msgName,
                    symbolName: imp.msgName,
                    implementsType: imp.implementsType
                });
            });
            // if already imported, addd implementsType
            alreadyInImports.forEach(imp => {
                const index = localSymbols.findIndex(l => l.source === imp.filename && l.symbolName === imp.msgName);
                localSymbols[index].implementsType = imp.implementsType;
            });
        });
        // update localSymbols for any conflicts
        localSymbols.forEach(sym => {
            // aside from exports, update readAs names...
            if (sym.readAs === sym.symbolName &&
                hasConflict(sym.symbolName) &&
                sym.type !== 'export') {
                sym.readAs = findAvailableName(sym.symbolName);
            }
            // add to symbols
            symbols.push({
                ref: ref.filename,
                ...sym
            });
        });
    });
    return symbols;
};
exports.parseFullyTraversedProtoImports = parseFullyTraversedProtoImports;
const traverse = (store, ref) => {
    const context = new TraverseContext(store, ref);
    // @ts-ignore
    const obj = {
        imports: ref.proto.imports,
        package: ref.proto.package,
        root: (0, exports.recursiveTraversal)(store, ref, ref.proto.root, context, [], false),
        parsedImports: null,
        parsedExports: null,
        importNames: {},
    };
    obj.parsedImports = context.imports;
    obj.parsedExports = context.exports;
    obj.acceptsInterface = context.acceptsInterface;
    obj.implementsInterface = context.implementsInterface;
    // just bc devs use proto syntax for types in the same file
    // does not mean we need to import them
    // delete any imports related to "this" file
    // delete obj.importNames[ref.filename];
    delete obj.parsedImports[ref.filename];
    return obj;
};
exports.traverse = traverse;
const getAllRefs = (store, ref) => {
    const importRefs = ref.proto.imports?.map(imp => store.findProto(imp)) ?? [];
    return importRefs.reduce((m, v) => {
        return [...m, ...getAllRefs(store, v)];
    }, importRefs);
};
const traverseFields = (store, ref, obj, context, traversal) => {
    return Object.keys(obj.fields).reduce((m, mykey) => {
        const field = obj.fields[mykey];
        let fieldName = mykey;
        const regexp = /([a-zA-Z0-9]+)[_]+([0-9]+)$/;
        if (regexp.test(fieldName)) {
            const matches = fieldName.match(regexp);
            if (matches?.length) {
                const begin = fieldName.split(matches[1])[0];
                fieldName = `${begin}${matches[1]}${matches[2]}`;
            }
        }
        const serialize = () => {
            if (typeof field.toJSON !== 'undefined') {
                // non-traversed
                return field.toJSON({ keepComments: true });
            }
            // traversed
            // field.name is used for proto!
            field.name = fieldName;
            field.message = obj.name;
            field.package = ref.proto.package;
            return field;
        };
        const implementsAcceptsAny = (0, x_cosmology_ast_1.getPluginValue)('interfaces.enabled', ref.proto.package, store.options);
        if (implementsAcceptsAny && field.options?.['(cosmos_proto.accepts_interface)']) {
            const value = field.options['(cosmos_proto.accepts_interface)'];
            // some of these contain a comma ...
            value.split(',').map(a => a.trim()).forEach(name => {
                context.addAccepts(name, obj.name);
            });
        }
        let found = null;
        if (utils_1.SCALAR_TYPES.includes(field.type)) {
            m[fieldName] = {
                parsedType: { name: field.type, type: 'native' },
                isScalar: true,
                typeNum: utils_1.SCALAR_TYPES.indexOf(field.type),
                ...serialize()
            };
            return m;
        }
        // nested scope first
        found = (0, lookup_1.lookupNested)(ref, traversal, field.type);
        if (found) {
            m[fieldName] = {
                scope: found.scope,
                parsedType: (0, utils_1.instanceType)(found),
                ...serialize(),
            };
            return m;
        }
        // local scope second
        found = (0, lookup_1.lookup)(store, ref, field.type);
        if (found) {
            m[fieldName] = {
                scope: found.scope,
                parsedType: (0, utils_1.instanceType)(found),
                ...serialize(),
            };
            return m;
        }
        found = (0, lookup_1.importLookup)(store, ref, field.type);
        if (found) {
            context.addImport(found.import, found.name);
            m[fieldName] = {
                parsedType: (0, utils_1.instanceType)(found.obj),
                scopeType: 'import',
                scope: [found.obj.scope],
                ...serialize(),
                importedName: found.importedName,
                import: found.import,
            };
            return m;
        }
        // found = protoImportLookup(store, ref, field.type);
        // if (found) {
        //     imports[found.import] = imports[found.import] || [];
        //     imports[found.import] = [...new Set([...imports[found.import], found.name])];
        //     m[fieldName] = {
        //         parsedType: instanceType(found.obj),
        //         scopeType: 'protoImport',
        //         scope: [found.package],
        //         ...serialize(),
        //         importedName: found.importedName,
        //         import: found.import,
        //     };
        //     return m;
        // }
        // new scope lookup (TODO: replace above cases)
        const typeNames = (0, utils_1.lookupSymbolScopes)(field.type, ref.proto.package + '.dummy');
        for (let lookupType of typeNames) {
            found = (0, lookup_1.protoScopeImportLookup)(store, ref, lookupType);
            if (found) {
                context.addImport(found.import, found.name);
                m[fieldName] = {
                    parsedType: (0, utils_1.instanceType)(found.obj),
                    scopeType: 'protoImport',
                    scope: found.obj.scope ? found.obj.scope : [found.package],
                    ...serialize(),
                    importedName: found.importedName,
                    import: found.import,
                };
                return m;
            }
        }
        // e.g. akash/deployment/v1beta2/service.proto
        // referencing messages in another file, and so we need access through our imports
        // if we get this issue again, this should be recursive and not just one level...
        const importRefs = ref.proto.imports.map(imp => store.findProto(imp));
        // const importRefs = getAllRefs(store, ref);
        for (let importRef of importRefs) {
            const typeNames = (0, utils_1.lookupSymbolScopes)(field.type, importRef.proto.package + '.dummy');
            for (let lookupType of typeNames) {
                found = (0, lookup_1.protoScopeImportLookup)(store, importRef, lookupType);
                if (found) {
                    context.addImport(found.import, found.name);
                    m[fieldName] = {
                        parsedType: (0, utils_1.instanceType)(found.obj),
                        scopeType: 'protoImport',
                        scope: found.obj.scope ? found.obj.scope : [found.package],
                        ...serialize(),
                        importedName: found.importedName,
                        import: found.import,
                    };
                    return m;
                }
            }
        }
        console.warn(`
${obj.name}.${field.name}: ${field.type} NOT FOUND from ${ref.filename} in ${ref.proto.package}
you should contact the maintainers.
`);
        return m;
    }, {});
};
const traverseType = (store, ref, obj, context, traversal, isNested) => {
    let nested = null;
    if (obj.nested) {
        nested = Object.keys(obj.nested).reduce((m, key) => {
            m[key] = (0, exports.recursiveTraversal)(store, ref, obj.nested[key], context, [...traversal, key], true);
            return m;
        }, {});
    }
    if (!isNested) {
        context.addExport(obj.name);
    }
    const traversed = {
        type: 'Type',
        name: obj.name,
        package: ref.proto.package,
        options: obj.options,
        oneofs: obj.oneofs ? Object.keys(obj.oneofs).reduce((m, v) => {
            m[v] = {
                // parse oneof
                oneof: obj.oneofs[v].oneof.map(name => name)
            };
            return m;
        }, {}) : undefined,
        fields: traverseFields(store, ref, obj, context, traversal),
        nested,
        keyTypes: [],
        comment: obj.comment
    };
    // parse keyType
    const hasKeyType = Object.keys(traversed.fields).some(field => !!traversed.fields[field].keyType);
    let keyTypes = [];
    if (hasKeyType) {
        keyTypes = Object.keys(traversed.fields)
            .filter(field => !!traversed.fields[field].keyType)
            .map(field => {
            return {
                name: field,
                ...traversed.fields[field]
            };
        });
    }
    traversed.keyTypes = keyTypes;
    const implementsAcceptsAny = (0, x_cosmology_ast_1.getPluginValue)('interfaces.enabled', ref.proto.package, store.options);
    if (implementsAcceptsAny && traversed.options?.["(cosmos_proto.implements_interface)"]) {
        const name = traversed.options['(cosmos_proto.implements_interface)'];
        context.addImplements(name, obj.name);
    }
    return traversed;
};
const traverseEnum = (store, ref, obj, context) => {
    return {
        type: 'Enum',
        name: obj.name,
        ...obj.toJSON({ keepComments: true })
    };
};
const traverseField = (store, ref, obj, context) => {
    return {
        // type is already a property on field
        name: obj.name,
        ...obj.toJSON({ keepComments: true })
    };
};
const traverseServiceMethod = (store, ref, obj, context, name, traversal) => {
    const service = obj.methods[name];
    const { requestType, responseType, options, comment } = service;
    let responseObject = (0, lookup_1.lookupAny)(store, ref, requestType);
    if (!responseObject) {
        throw new Error('Symbol not found ' + requestType);
    }
    let requestObject = (0, lookup_1.lookupAny)(store, ref, requestType);
    if (!requestObject) {
        throw new Error('Symbol not found ' + requestType);
    }
    const fields = traverseFields(store, ref, requestObject.obj, context, traversal);
    // @ts-ignore
    const info = (0, services_1.parseService)({
        options,
        fields
    });
    const svc = {
        type: 'ServiceMethod',
        info,
        name,
        comment,
        requestType,
        responseType,
        options,
        fields
    };
    if (info) {
        // TODO is this still needed?
        // get casing info for request objects
        Object.keys(requestObject.obj.fields).map(fieldName => {
            const field = requestObject.obj.fields[fieldName];
            const protoCasing = store.options.prototypes.parser.keepCase ?
                field.options['(telescope:orig)'] :
                field.options['(telescope:camel)'];
            const origCase = field.options['(telescope:orig)'];
            svc.info.casing = svc.info.casing || {};
            svc.info.casing[origCase] = protoCasing;
        });
    }
    store.registerRequest(svc);
    return svc;
};
const traverseService = (store, ref, obj, context, traversal) => {
    const json = obj.toJSON({ keepComments: true });
    const methods = Object.keys(json.methods).reduce((m, key) => {
        m[key] = traverseServiceMethod(store, ref, json, context, key, traversal);
        return m;
    }, {});
    return {
        type: 'Service',
        name: obj.name,
        ...obj.toJSON({ keepComments: true }),
        methods
    };
};
const recursiveTraversal = (store, ref, obj, context, traversal, isNested) => {
    if (obj instanceof protobufjs_1.Type) {
        return traverseType(store, ref, obj, context, traversal, isNested);
    }
    if (obj instanceof protobufjs_1.Enum) {
        return traverseEnum(store, ref, obj, context);
    }
    if (obj instanceof protobufjs_1.Service) {
        return traverseService(store, ref, obj, context, traversal);
    }
    if (obj instanceof protobufjs_1.Field) {
        return traverseField(store, ref, obj, context);
    }
    if (obj instanceof protobufjs_1.Root) {
        if (obj.nested) {
            return Object.keys(obj.nested).reduce((m, key) => {
                m.nested[key] = (0, exports.recursiveTraversal)(store, ref, obj.nested[key], context, [...traversal, key], isNested);
                return m;
            }, {
                type: 'Root',
                nested: {}
            });
        }
        else {
            throw new Error(`recursiveTraversal() [Root] cannot find protobufjs Type in file: ${ref.filename}`);
        }
    }
    if (obj instanceof protobufjs_1.Namespace) {
        if (obj.nested) {
            return Object.keys(obj.nested).reduce((m, key) => {
                m.nested[key] = (0, exports.recursiveTraversal)(store, ref, obj.nested[key], context, [...traversal, key], isNested);
                return m;
            }, {
                type: 'Namespace',
                nested: {}
            });
        }
        else {
            throw new Error(`recursiveTraversal() [Namespace] cannot find protobufjs Type in file: ${ref.filename}`);
        }
    }
    throw new Error('recursiveTraversal() cannot find protobufjs Type');
};
exports.recursiveTraversal = recursiveTraversal;
