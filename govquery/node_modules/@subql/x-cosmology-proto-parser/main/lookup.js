"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.externalLookup = exports.lookupLocal = exports.lookupAnyFromImports = exports.lookupAny = exports.lookupNested = exports.lookup = exports.protoScopeImportLookup = exports.protoImportLookup = exports.importLookup = exports.recursiveLookup = void 0;
const _1 = require("./");
const recursiveLookup = (proto, name, scope = [], allowNested = true) => {
    if (!proto)
        return;
    if (proto.hasOwnProperty(name))
        return {
            name,
            scope,
            ...proto[name]
        };
    if (allowNested && proto) {
        const keys = Object.keys(proto);
        for (let k = 0; k < keys.length; k++) {
            const found = (0, exports.recursiveLookup)(proto[keys[k]].nested, name, [...scope, keys[k]], allowNested);
            if (found) {
                return {
                    name,
                    ...found
                };
            }
            ;
        }
    }
};
exports.recursiveLookup = recursiveLookup;
const getRoot = (ref) => {
    if (ref.traversed)
        return ref.traversed;
    return ref.proto;
};
/*

  "imports": [
    "google/api/expr/v1alpha1/syntax.proto",
    "google/protobuf/empty.proto",
    "google/protobuf/struct.proto"
  ],

  ...

  "type": "Empty"

  finds Empty inside of the import

*/
const importLookup = (store, ref, name) => {
    const root = getRoot(ref);
    const objectsFromImports = root?.imports?.map(imp => {
        const ref = store.findProto(imp);
        if (!ref) {
            throw new Error(`missing proto import ${imp}`);
        }
        return {
            name,
            importType: 'import',
            import: imp,
            importedName: name,
            obj: (0, exports.lookup)(store, ref, name, false),
        };
    }).filter(a => !!a.obj) ?? [];
    if (objectsFromImports.length)
        return objectsFromImports[0];
};
exports.importLookup = importLookup;
/*

  "imports": [
    "google/api/expr/v1alpha1/syntax.proto",
    "google/protobuf/empty.proto",
    "google/protobuf/struct.proto"
  ],

  ...

  "type": "google.protobuf.NullValue"

  finds NullValue directly from package name

*/
const protoImportLookup = (store, ref, name) => {
    const root = getRoot(ref);
    if (name.startsWith('.'))
        name = name.replace(/^\./, '');
    const nameAsArray = name.split('.');
    const objectName = nameAsArray.pop();
    const packageName = nameAsArray.join('.');
    const objs = store.getProtos()
        // 1 ask all package files of package, e.g "google.protobuf"
        .filter(proto => proto.proto.package === packageName)
        // 2 cross-checking w the imports by filter()
        .filter(proto => proto.filename === ref.filename ||
        root.imports?.includes(proto.filename))
        .map((ref) => {
        return {
            import: ref.filename,
            obj: (0, exports.lookup)(store, ref, objectName, false)
        };
    })
        .filter(a => !!a.obj);
    if (objs.length) {
        return {
            import: objs[0].import,
            importType: 'protoImport',
            obj: objs[0].obj,
            importedName: name,
            name: objectName,
            package: packageName
        };
    }
};
exports.protoImportLookup = protoImportLookup;
const protoScopeImportLookup = (store, ref, name) => {
    const root = getRoot(ref);
    // TODO pass in the imports and this ref
    // e.g. only include packges of those files !!!!!
    // this is currently looking at ALL protos
    const parsed = store.parseScope(name);
    if (!parsed) {
        return;
    }
    const packageName = parsed.package;
    const nameAsArray = parsed.nested.split('.');
    let lookupFn;
    if (nameAsArray.length > 1) {
        // nested!
        const traversal = [...packageName.split('.'), ...nameAsArray];
        const nameToLookFor = traversal.pop();
        lookupFn = (ref) => {
            return {
                import: ref.filename,
                obj: (0, exports.lookupNested)(ref, traversal, nameToLookFor, true)
            };
        };
    }
    else {
        // single lookup
        lookupFn = (ref) => {
            return {
                import: ref.filename,
                obj: (0, exports.lookup)(store, ref, parsed.nested, false)
            };
        };
    }
    const refs = store.getProtos()
        // 1 ask all package files of package, e.g "google.protobuf"
        .filter(proto => proto.proto.package === packageName)
        // 2 cross-checking w the imports by filter()
        .filter(proto => proto.filename === ref.filename ||
        root.imports?.includes(proto.filename));
    for (let ref of refs) {
        const found = lookupFn(ref);
        if (found && found.obj) {
            if (nameAsArray.length > 1) {
                return {
                    import: found.import,
                    importType: 'protoImport',
                    obj: found.obj,
                    // not sure why scope doesn't handle this
                    // so we're wrapping with underscores here
                    // EXAMPLE: google/logging/v2/logging_metrics
                    // EXAMPLE: google/api/servicecontrol/v1/distribution
                    importedName: nameAsArray.join('_'),
                    name: nameAsArray.join('_'),
                    package: packageName
                };
            }
            else {
                return {
                    import: found.import,
                    importType: 'protoImport',
                    obj: found.obj,
                    importedName: name,
                    name: parsed.nested,
                    package: packageName
                };
            }
        }
    }
};
exports.protoScopeImportLookup = protoScopeImportLookup;
const lookup = (store, ref, name, allowNested = true) => {
    const root = getRoot(ref);
    if (!root.package) {
        console.warn(`There's no package definition in ${ref.filename}`);
        return;
    }
    const nested = (0, _1.getNestedProto)(root);
    return (0, exports.recursiveLookup)(nested, name, [root.package], allowNested);
};
exports.lookup = lookup;
const lookupNested = (ref, traversal, name, allowNested = true) => {
    const root = getRoot(ref);
    const nested = (0, _1.getNested)(root, traversal);
    const scoped = [...traversal].splice(root.package.split('.').length);
    return (0, exports.recursiveLookup)(nested, name, [root.package, ...scoped], allowNested);
};
exports.lookupNested = lookupNested;
const lookupAny = (store, ref, name) => {
    let refObject = (0, exports.lookupLocal)(store, ref, name);
    if (refObject) {
        return refObject;
    }
    refObject = (0, exports.externalLookup)(store, ref, name);
    if (refObject) {
        return refObject;
    }
};
exports.lookupAny = lookupAny;
// recursively look at all imports and find what you're looking for...
const lookupAnyFromImports = (store, ref, name) => {
    let refObject = (0, exports.lookupAny)(store, ref, name);
    if (refObject)
        return refObject;
    const imports = Object.keys(ref.traversed?.parsedImports ?? {});
    for (let i = 0; i < imports.length; i++) {
        const ref = store.findProto(imports[i]);
        refObject = (0, exports.lookupAnyFromImports)(store, ref, name);
        if (refObject)
            return refObject;
    }
    return refObject;
};
exports.lookupAnyFromImports = lookupAnyFromImports;
const lookupLocal = (store, ref, name) => {
    const root = getRoot(ref);
    let refObject = (0, exports.lookup)(store, ref, name);
    if (refObject) {
        return {
            name,
            import: ref.filename,
            importType: 'local',
            importedName: name,
            package: root.package,
            obj: refObject
        };
    }
};
exports.lookupLocal = lookupLocal;
const externalLookup = (store, ref, name) => {
    let refObject;
    refObject = (0, exports.protoImportLookup)(store, ref, name);
    if (refObject) {
        return refObject;
    }
    refObject = (0, exports.importLookup)(store, ref, name);
    if (refObject) {
        return refObject;
    }
};
exports.externalLookup = externalLookup;
