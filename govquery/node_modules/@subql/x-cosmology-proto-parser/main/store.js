"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtoStore = exports.parseProto = void 0;
const glob_1 = require("glob");
const protobufjs_1 = require("@cosmology/protobufjs");
const fs_1 = require("fs");
const path_1 = require("path");
const _1 = require("./");
const traverse_1 = require("./traverse");
const lookup_1 = require("./lookup");
const x_cosmology_types_1 = require("@subql/x-cosmology-types");
const any_1 = __importDefault(require("./native/any"));
const descriptor_1 = __importDefault(require("./native/descriptor"));
const duration_1 = __importDefault(require("./native/duration"));
const timestamp_1 = __importDefault(require("./native/timestamp"));
const empty_1 = __importDefault(require("./native/empty"));
const field_mask_1 = __importDefault(require("./native/field_mask"));
const struct_1 = __importDefault(require("./native/struct"));
const wrappers_1 = __importDefault(require("./native/wrappers"));
const resolver_1 = require("./resolver");
const x_cosmology_utils_1 = require("@subql/x-cosmology-utils");
const GOOGLE_PROTOS = [
    ['google/protobuf/any.proto', any_1.default],
    ['google/protobuf/duration.proto', duration_1.default],
    ['google/protobuf/descriptor.proto', descriptor_1.default],
    ['google/protobuf/timestamp.proto', timestamp_1.default],
    ['google/protobuf/empty.proto', empty_1.default],
    ['google/protobuf/struct.proto', struct_1.default],
    ['google/protobuf/wrappers.proto', wrappers_1.default],
    ['google/protobuf/field_mask.proto', field_mask_1.default]
];
const protoParseOptionsDefaults = {
    keepCase: false,
    alternateCommentMode: true,
    preferTrailingComment: false
};
const parseProto = (content, options) => {
    if (!options) {
        options = protoParseOptionsDefaults;
    }
    return (0, protobufjs_1.parse)(content, options);
};
exports.parseProto = parseProto;
class ProtoStore {
    files;
    protoDirs;
    deps;
    protos;
    packages;
    options;
    requests = {};
    responses = {};
    _traversed = false;
    _symbols = [];
    constructor(protoDirs = [], options = x_cosmology_types_1.defaultTelescopeOptions) {
        this.protoDirs = protoDirs.map(protoDir => (0, path_1.resolve)(protoDir));
        this.options = options;
    }
    findProto(filename) {
        return this.getProtos().find(proto => {
            return proto.filename === filename;
        });
    }
    findProtoWhere(fn) {
        return this.getProtos().find(ref => {
            return fn(ref);
        });
    }
    filterProtoWhere(fn) {
        return this.getProtos().filter(ref => {
            return fn(ref);
        });
    }
    findProtoObject(filename, name) {
        const proto = this.findProto(filename);
        return (0, _1.getNestedProto)(proto.traversed ?? proto.proto)[name];
    }
    registerRequest(svc) {
        this.requests[svc.requestType] = svc;
        this.responses[svc.responseType] = svc;
    }
    ;
    processProtos(contents) {
        return contents.map(({ absolute, filename, content }) => {
            try {
                const proto = (0, exports.parseProto)(content, this.options.prototypes.parser);
                return {
                    absolute,
                    filename,
                    proto,
                };
            }
            catch (e) {
                console.error(`${filename} has a proto syntax error`);
                throw e;
            }
        });
    }
    ;
    getProtos() {
        if (this.protos)
            return this.protos;
        const contents = this.protoDirs.reduce((m, protoDir) => {
            const protoSplat = (0, path_1.join)(protoDir, '**', '*.proto');
            const protoFiles = (0, glob_1.sync)((0, x_cosmology_utils_1.convertIfWinPath)(x_cosmology_utils_1.ToUnixPath, '/', protoSplat));
            const contents = protoFiles.map(filename => {
                const processedFilename = (0, x_cosmology_utils_1.convertIfWinPath)(x_cosmology_utils_1.ToWindowsPath, '\\', filename);
                return ({
                    absolute: processedFilename,
                    filename: filename.split((0, x_cosmology_utils_1.convertIfWinPath)(x_cosmology_utils_1.ToUnixPath, '/', protoDir))[1].replace(/^\//, ''),
                    content: (0, fs_1.readFileSync)(processedFilename, 'utf-8')
                });
            });
            return [...m, ...contents];
        }, []);
        const registeredProtos = [];
        const protos = this.processProtos(contents).filter(proto => {
            if (registeredProtos.includes(proto.filename)) {
                if (this.options.logLevel >= x_cosmology_types_1.TelescopeLogLevel.Warn) {
                    console.warn(`${proto.filename} already included!`);
                }
                return false;
            }
            registeredProtos.push(proto.filename);
            return true;
        });
        const neededFromGoogle = [];
        this.getDependencies(protos).map(dep => {
            const google = dep.imports?.filter(imp => imp.startsWith('google/protobuf')) ?? [];
            if (google.length) {
                google.forEach(goog => {
                    // if they don't got it, let's give it to 'em!
                    const found = contents.find(file => file.filename === goog);
                    if (found)
                        return;
                    // NOT FOUND
                    const filler = GOOGLE_PROTOS.find(([f, v]) => { return f === goog; });
                    if (!filler)
                        return; // technically an error should be thrown
                    // we have the filler
                    if (!neededFromGoogle.find(file => file.filename === goog)) {
                        neededFromGoogle.push({
                            absolute: filler[0],
                            filename: filler[0],
                            content: filler[1]
                        });
                    }
                });
            }
        });
        const missingProtos = this.processProtos(neededFromGoogle);
        this.protos = [...protos, ...missingProtos];
        return this.protos;
    }
    getPackages() {
        if (this.packages)
            return this.packages;
        this.packages = this.getProtos().reduce((m, ref) => {
            return [...new Set([...m, ref.proto.package])];
        }, []);
        // LONGEST strings first, for better matching
        this.packages = this.packages.sort((a, b) => {
            return b.length - a.length;
        }).filter(Boolean);
        return this.packages;
    }
    parseScope(type) {
        const pkgs = this.getPackages();
        for (let pkg of pkgs) {
            const found = (0, _1.getPackageAndNestedFromStr)(type, pkg);
            if (found)
                return found;
        }
    }
    getDeps() {
        if (this.deps)
            return this.deps;
        this.deps = this.getDependencies(this.getProtos());
        return this.deps;
    }
    getDependencies(protos) {
        return protos.map(el => {
            const { filename, proto: { package: pkg, imports } } = el;
            return {
                filename,
                package: pkg,
                imports
            };
        });
    }
    traverseAll() {
        if (this._traversed)
            return;
        let actualFiles = new Set();
        let resolver = new resolver_1.ProtoResolver(this.getDeps());
        this.protos = this.getProtos().map((ref) => {
            const isHardExcluded = this.options?.prototypes?.excluded?.hardProtos && (0, _1.isRefExcluded)(ref, {
                protos: this.options?.prototypes?.excluded?.hardProtos
            });
            if (isHardExcluded) {
                return null;
            }
            if (!actualFiles.has(ref.filename)) {
                // get included imported files
                const isIncluded = (0, _1.isRefIncluded)(ref, this.options.prototypes.includes);
                const isExcluded = (0, _1.isRefExcluded)(ref, this.options.prototypes.excluded);
                if (isIncluded && !isExcluded) {
                    const deps = resolver.resolve(ref.filename);
                    for (const dep of deps) {
                        actualFiles.add(dep);
                    }
                }
            }
            return {
                absolute: ref.absolute,
                filename: ref.filename,
                proto: ref.proto,
                traversed: (0, traverse_1.traverse)(this, ref)
            };
        }).filter(Boolean);
        this._symbols = (0, traverse_1.parseFullyTraversedProtoImports)(this, actualFiles);
        // process import names
        this.protos = this.protos.map((ref) => {
            if (!actualFiles.has(ref.filename)) {
                return null;
            }
            const traversed = ref.traversed;
            const symbs = this._symbols
                .filter(f => f.ref === ref.filename);
            traversed.importNames = (0, traverse_1.symbolsToImportNames)(ref, symbs);
            // now add any inferred imports as a result of accepts/implements
            symbs
                .filter(f => f.ref !== f.source)
                .forEach(f => {
                traversed.parsedImports[f.source] = traversed.parsedImports[f.source] || [];
                traversed.parsedImports[f.source] = [...new Set([...traversed.parsedImports[f.source], f.symbolName])];
            });
            return {
                ...ref,
                traversed
            };
        }).filter(Boolean);
        //reset and recalculate pkgs and deps later
        this.packages = null;
        this.deps = null;
        this._traversed = true;
    }
    get(from, name) {
        if (!this._traversed)
            throw new Error('get() requires traversal');
        return (0, lookup_1.lookupAny)(this, from, name);
    }
    getImportFromRef(ref, name) {
        if (!this._traversed)
            throw new Error('getImportFromRef() requires traversal');
        return (0, lookup_1.lookupAnyFromImports)(this, ref, name);
    }
    getTypeUrlMap(ref) {
        return (0, _1.createTypeUrlTypeMap)(this, ref);
    }
    // DOCUMENTATION
    getServices(myBase) {
        const refs = this.getProtos().filter((ref) => {
            const proto = (0, _1.getNestedProto)(ref.traversed);
            //// Anything except Msg Service OK...
            const allowedRpcServices = this.options.rpcClients.enabledServices.filter(a => a !== 'Msg');
            const found = allowedRpcServices.some(svc => {
                return proto?.[svc] &&
                    proto[svc]?.type === 'Service';
            });
            if (!found) {
                return;
            }
            ///
            return true;
        });
        const check = refs.filter((ref) => {
            const [base] = ref.proto.package.split('.');
            return base === myBase;
        });
        if (!check.length) {
            return {};
        }
        const packages = refs.reduce((m, ref) => {
            const [base] = ref.proto.package.split('.');
            if (base === myBase) {
                if (!m[ref.proto.package])
                    m[ref.proto.package] = [];
                m[ref.proto.package].push(ref);
            }
            return m;
        }, {});
        return packages;
    }
}
exports.ProtoStore = ProtoStore;
