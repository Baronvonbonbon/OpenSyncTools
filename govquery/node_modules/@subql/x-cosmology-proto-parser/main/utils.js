"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEmptyProtoRef = exports.instanceType = exports.SCALAR_TYPES = exports.getEnums = exports.getTypes = exports.getServices = exports.getPackageAndNestedFromStr = exports.createTypeUrlTypeMap = exports.lookupSymbolScopes = exports.getObjectName = exports.isRefIncluded = exports.isRefExcluded = void 0;
const protobufjs_1 = require("@cosmology/protobufjs");
const x_cosmology_utils_1 = require("@subql/x-cosmology-utils");
const _1 = require(".");
var x_cosmology_utils_2 = require("@subql/x-cosmology-utils");
Object.defineProperty(exports, "isRefExcluded", { enumerable: true, get: function () { return x_cosmology_utils_2.isRefExcluded; } });
Object.defineProperty(exports, "isRefIncluded", { enumerable: true, get: function () { return x_cosmology_utils_2.isRefIncluded; } });
Object.defineProperty(exports, "getObjectName", { enumerable: true, get: function () { return x_cosmology_utils_2.getObjectName; } });
// https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/descriptor.cc#L3798-L3812
// NOTE: sometimes you need to pass in `.Dummy` for the first call,
// for example, osmosis.gamm.v1beta1.Dummy, so the first pop()
// that gets called, it will still look relative to the current module scope
const lookupSymbolScopes = (name, relativeTo, list) => {
    // fully-qualified name
    if (name.startsWith('.'))
        return [name.replace(/^\./, '')];
    if (!list)
        list = [];
    const relativeToParts = relativeTo.split('.');
    // This first searches siblings of relative_to (pop off relative_to)
    relativeToParts.pop();
    const newName = [...relativeToParts, ...name.split('.')].join('.');
    if (newName === name)
        return [...list, name];
    return (0, exports.lookupSymbolScopes)(name, relativeToParts.join('.'), [...list, newName]);
};
exports.lookupSymbolScopes = lookupSymbolScopes;
const createTypeUrlTypeMap = (store, fromRef // ref to create HashMap for (includes proper import names)
) => {
    const result = {};
    const interfaces = [];
    Object.keys(fromRef.traversed?.acceptsInterface ?? {}).forEach(implementsType => {
        interfaces.push(implementsType);
    });
    store.getProtos().forEach(ref => {
        if (ref.traversed?.implementsInterface) {
            Object.keys(ref.traversed.implementsInterface).forEach(implementsType => {
                if (!interfaces.includes(implementsType))
                    return;
                const types = ref.traversed?.implementsInterface[implementsType];
                result[implementsType] = result[implementsType] || [];
                result[implementsType].push({
                    ref: ref.filename,
                    pkg: ref.proto.package,
                    types: types?.map(type => {
                        const protoType = (0, _1.getNestedProto)(ref.proto)[type];
                        const typeUrl = (0, x_cosmology_utils_1.getTypeUrl)(ref.proto, protoType);
                        const aminoType = (0, x_cosmology_utils_1.getAminoTypeNameByRef)(fromRef, store.options, ref.proto, protoType);
                        return {
                            typeUrl,
                            aminoType,
                            type,
                            importAs: (0, x_cosmology_utils_1.getTypeNameFromFieldName)(type, ref.filename, fromRef)
                        };
                    })
                });
            });
        }
    });
    return result;
};
exports.createTypeUrlTypeMap = createTypeUrlTypeMap;
const getPackageAndNestedFromStr = (type, pkg) => {
    if (type.startsWith(pkg) && type.length > pkg.length) {
        const nested = type.substring(pkg.length + 1);
        return {
            nested,
            package: pkg
        };
    }
};
exports.getPackageAndNestedFromStr = getPackageAndNestedFromStr;
const getServices = (root) => {
    const nested = (0, _1.getNestedProto)(root);
    return Object.keys(nested).map(key => {
        return nested[key];
    }).filter(obj => {
        return obj instanceof protobufjs_1.Service;
    }).map(el => {
        return {
            name: el.name,
            ...el.toJSON({ keepComments: true })
        };
    });
};
exports.getServices = getServices;
const getTypes = (root) => {
    const nested = (0, _1.getNestedProto)(root);
    return Object.keys(nested).map(key => {
        return nested[key];
    }).filter(obj => {
        return obj instanceof protobufjs_1.Type;
    }).map(el => {
        return {
            name: el.name,
            ...el.toJSON({ keepComments: true })
        };
    });
};
exports.getTypes = getTypes;
const getEnums = (root) => {
    const nested = (0, _1.getNestedProto)(root);
    return Object.keys(nested).map(key => {
        return nested[key];
    }).filter(obj => {
        return obj instanceof protobufjs_1.Enum;
    }).map(el => {
        return {
            name: el.name,
            ...el.toJSON({ keepComments: true })
        };
    });
};
exports.getEnums = getEnums;
exports.SCALAR_TYPES = [
    "double",
    "float",
    "int32",
    "uint32",
    "sint32",
    "fixed32",
    "sfixed32",
    "int64",
    "uint64",
    "sint64",
    "fixed64",
    "sfixed64",
    "bool",
    "string",
    "bytes" // 14
];
const instanceType = (obj) => {
    if (obj instanceof protobufjs_1.Type) {
        return {
            name: obj.name,
            type: 'Type'
        };
    }
    if (obj instanceof protobufjs_1.Enum) {
        return {
            name: obj.name,
            type: 'Enum'
        };
    }
    if (obj instanceof protobufjs_1.Service) {
        return {
            name: obj.name,
            type: 'Service'
        };
    }
    if (obj instanceof protobufjs_1.Root) {
        return {
            type: 'Root'
        };
    }
    if (obj instanceof protobufjs_1.Namespace) {
        return {
            type: 'Namespace'
        };
    }
    // if (obj.name === 'Timestamp') {
    //     return {
    //         name: obj.name,
    //         type: 'google'
    //     };
    // }
    // if (obj.name === 'Duration') {
    //     return {
    //         name: obj.name,
    //         type: 'google'
    //     };
    // }
    if (obj.name.match(/^[a-z]/)) {
        throw new Error('instanceType() cannot find protobufjs Type');
    }
    // duck typing...
    // TODO why did we lose instance types/names?
    if (obj.fields) {
        return {
            name: obj.name,
            type: 'Type'
        };
    }
    if (obj.values) {
        return {
            name: obj.name,
            type: 'Enum'
        };
    }
    throw new Error('instanceType() cannot find protobufjs Type');
};
exports.instanceType = instanceType;
/**
 * get a protoref instance for scope check by package.
 * @param pkg package used to do the scope check.
 * @returns
 */
const createEmptyProtoRef = (pkg, filename) => {
    return {
        absolute: '',
        filename: filename,
        proto: {
            package: pkg,
            imports: null,
            root: {},
            importNames: null
        },
        traversed: {
            package: pkg,
            imports: null,
            root: {},
            importNames: null,
            acceptsInterface: {},
            implementsInterface: {},
            parsedExports: {},
            parsedImports: {},
            symbols: null
        }
    };
};
exports.createEmptyProtoRef = createEmptyProtoRef;
