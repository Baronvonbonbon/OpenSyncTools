{"version":3,"file":"IPFSHTTPClientLite.js","sourceRoot":"","sources":["../../../src/project/IpfsHttpClientLite/IPFSHTTPClientLite.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020-2025 SubQuery Pte Ltd authors & contributors\n// SPDX-License-Identifier: GPL-3.0\n\nimport axios from 'axios';\nimport FormData from 'form-data';\nimport {streamCat} from './utils';\n\ntype ContentData = string | Uint8Array;\n\ntype Content =\n  | {\n      content: ContentData;\n      path: string;\n    }\n  | ContentData;\n\ntype AddOptions = {\n  pin?: boolean;\n  cidVersion?: number;\n  wrapWithDirectory?: boolean;\n};\n\ntype AddResult = {\n  path: string;\n  cid: string;\n  size: number;\n};\n\nexport class IPFSHTTPClientLite {\n  constructor(private option: {url: string; headers?: Record<string, string>}) {\n    if (option.url === undefined) {\n      throw new Error('url is required');\n    }\n    this.option = option;\n  }\n\n  get url(): string {\n    return this.option.url.toString();\n  }\n\n  /**\n   * Returns content of the file addressed by a valid IPFS Path or CID\n   */\n  cat(ipfsCID: string): AsyncIterable<Uint8Array> {\n    return streamCat(this.option.url, ipfsCID);\n  }\n\n  /**\n   * Import a file or data into IPFS\n   */\n  async add(content: Content, options?: AddOptions): Promise<AddResult> {\n    const results = await this.addAll([content], options);\n\n    return results[0];\n  }\n\n  /**\n   * Pin a content with a given CID to a remote pinning service.\n   */\n  async pinRemoteAdd(cid: string, options: {service: string}): Promise<{Cid: string; Name: string; Status: string}> {\n    const url = new URL(`${this.url}/pin/remote/add`);\n    url.searchParams.append('arg', cid);\n    url.searchParams.append('service', options.service);\n    try {\n      const response = await axios.post(\n        url.toString(),\n        {},\n        {\n          headers: {\n            ...this.option.headers,\n          },\n        }\n      );\n      return response.data;\n    } catch (e) {\n      throw new Error(`Failed to pin CID ${cid} to remote service`, {cause: e});\n    }\n  }\n\n  /**\n   * Import multiple files and data into IPFS\n   */\n  async addAll(source: Content[], options?: AddOptions): Promise<AddResult[]> {\n    const formData = this.makeFormData(source);\n\n    const url = new URL(`${this.url}/add`);\n    if (options) {\n      url.searchParams.append('pin', options.pin?.toString() ?? 'true');\n      url.searchParams.append('cid-version', options.cidVersion?.toString() ?? '0');\n      url.searchParams.append('wrap-with-directory', options.wrapWithDirectory?.toString() ?? 'false');\n    }\n\n    try {\n      const response = await axios.post(url.toString(), formData, {\n        headers: {\n          ...this.option.headers,\n          ...formData.getHeaders(),\n        },\n        maxBodyLength: Infinity,\n        maxContentLength: Infinity,\n      });\n\n      const mapResponse = (raw: any): AddResult => ({\n        path: raw.Name,\n        cid: raw.Hash,\n        size: parseInt(raw.Size, 10),\n      });\n\n      // If only one file is uploaded then the response is an object.\n      if (typeof response.data === 'object') {\n        return [mapResponse(response.data)];\n      }\n\n      const jsonLines = (response.data.split('\\n') as string[]).filter((l) => l !== '');\n\n      return jsonLines.map((line) => JSON.parse(line)).map(mapResponse);\n    } catch (error) {\n      throw new Error(`Failed to upload files to IPFS`, {cause: error});\n    }\n  }\n\n  private makeFormData(contents: Content[]): FormData {\n    const formData = new FormData();\n    for (const content of contents) {\n      if (content instanceof Uint8Array) {\n        formData.append('data', Buffer.from(content));\n      } else if (typeof content === 'string') {\n        formData.append('data', content);\n      } else {\n        formData.append('data', content.content, {filename: content.path});\n      }\n    }\n\n    return formData;\n  }\n}\n"]}