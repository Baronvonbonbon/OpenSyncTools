"use strict";
// Copyright 2020-2024 SubQuery Pte Ltd authors & contributors
// SPDX-License-Identifier: GPL-3.0
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IsEndBlockGreater = exports.tsProjectYamlPath = exports.FileReferenceImp = exports.mapToObject = exports.toJsonObject = exports.notifyUpdates = exports.forbidNonWhitelisted = exports.extensionIsYamlOrJSON = exports.extensionIsTs = exports.validateObject = exports.delay = exports.SemverVersionValidator = exports.validateSemver = exports.getMultichainManifestPath = exports.getProjectRootAndManifest = exports.findAvailablePort = exports.makeTempDir = exports.handleCreateSubqueryProjectError = exports.isFileReference = exports.DEFAULT_GIT_IGNORE = exports.DEFAULT_ENV_DEVELOP_LOCAL = exports.DEFAULT_ENV_LOCAL = exports.DEFAULT_ENV_DEVELOP = exports.DEFAULT_ENV = exports.DEFAULT_TS_MANIFEST = exports.DEFAULT_MANIFEST = exports.DEFAULT_MULTICHAIN_TS_MANIFEST = exports.DEFAULT_MULTICHAIN_MANIFEST = void 0;
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const class_validator_1 = require("class-validator");
const detect_port_1 = __importDefault(require("detect-port"));
const yaml = __importStar(require("js-yaml"));
const semver_1 = require("semver");
const update_notifier_1 = __importDefault(require("update-notifier"));
const constants_1 = require("../constants");
exports.DEFAULT_MULTICHAIN_MANIFEST = 'subquery-multichain.yaml';
exports.DEFAULT_MULTICHAIN_TS_MANIFEST = 'subquery-multichain.ts';
exports.DEFAULT_MANIFEST = 'project.yaml';
exports.DEFAULT_TS_MANIFEST = 'project.ts';
exports.DEFAULT_ENV = '.env';
exports.DEFAULT_ENV_DEVELOP = '.env.develop';
exports.DEFAULT_ENV_LOCAL = '.env.local';
exports.DEFAULT_ENV_DEVELOP_LOCAL = '.env.develop.local';
exports.DEFAULT_GIT_IGNORE = '.gitignore';
function isFileReference(value) {
    return value?.file && typeof value.file === 'string';
}
exports.isFileReference = isFileReference;
// Input manifest here, we might need to handler other error later on
function handleCreateSubqueryProjectError(err, pjson, rawManifest, logger) {
    if (JSON.stringify(err.message).includes(constants_1.RUNNER_ERROR_REGEX)) {
        logger.error(`Failed to init project, required runner is ${rawManifest.runner.node.name}, got ${pjson.name}`);
    }
    else {
        logger.error(err, 'Create Subquery project from given path failed!');
    }
}
exports.handleCreateSubqueryProjectError = handleCreateSubqueryProjectError;
async function makeTempDir() {
    const sep = path_1.default.sep;
    const tmpDir = os_1.default.tmpdir();
    const tempPath = await fs_1.default.promises.mkdtemp(`${tmpDir}${sep}`);
    return tempPath;
}
exports.makeTempDir = makeTempDir;
async function findAvailablePort(startPort, range = 10) {
    for (let port = startPort; port <= startPort + range; port++) {
        try {
            const _port = await (0, detect_port_1.default)(port);
            if (_port === port) {
                return port;
            }
        }
        catch (e) {
            return null;
        }
    }
    return null;
}
exports.findAvailablePort = findAvailablePort;
function getProjectRootAndManifest(subquery) {
    const project = {
        root: '',
        manifests: [],
    };
    const stats = fs_1.default.statSync(subquery);
    if (stats.isDirectory()) {
        project.root = subquery;
        if (fs_1.default.existsSync(path_1.default.resolve(subquery, exports.DEFAULT_MANIFEST))) {
            project.manifests.push(path_1.default.resolve(subquery, exports.DEFAULT_MANIFEST));
        }
        // Then check for a 'multichain manifest'
        else if (fs_1.default.existsSync(path_1.default.resolve(subquery, exports.DEFAULT_MULTICHAIN_MANIFEST))) {
            const multichainManifestContent = yaml.load(fs_1.default.readFileSync(path_1.default.resolve(subquery, exports.DEFAULT_MULTICHAIN_MANIFEST), 'utf8'));
            if (!multichainManifestContent.projects || !Array.isArray(multichainManifestContent.projects)) {
                throw new Error('Multichain manifest does not contain a valid "projects" field');
            }
            addMultichainManifestProjects(subquery, multichainManifestContent, project);
        }
        else {
            throw new Error(`Unable to resolve manifest file from given directory: ${subquery}`);
        }
    }
    else if (stats.isFile()) {
        const { dir, ext } = path_1.default.parse(subquery);
        if (!extensionIsTs(ext) && !extensionIsYamlOrJSON(ext)) {
            throw new Error(`Extension ${ext} not supported for project ${subquery}`);
        }
        project.root = dir;
        let projectYamlPath = subquery;
        if (extensionIsTs(ext)) {
            projectYamlPath = (0, exports.tsProjectYamlPath)(subquery);
            if (!fs_1.default.existsSync(projectYamlPath)) {
                throw new Error(`Could not find manifest ${projectYamlPath}, if pointing to a typescript manifest, please ensure build successfully`);
            }
        }
        const multichainManifestContent = yaml.load(fs_1.default.readFileSync(projectYamlPath, 'utf8'));
        // The project manifest could be empty
        if (multichainManifestContent === null) {
            throw new Error(`Read manifest content is null, ${projectYamlPath}`);
        }
        else if (multichainManifestContent.projects && Array.isArray(multichainManifestContent.projects)) {
            addMultichainManifestProjects(dir, multichainManifestContent, project);
        }
        else {
            project.manifests.push(projectYamlPath);
        }
    }
    project.root = path_1.default.resolve(project.root);
    // Convert manifest paths to be relative to the project root
    project.manifests = project.manifests.map((manifestPath) => {
        return path_1.default.relative(project.root, manifestPath);
    });
    return project;
}
exports.getProjectRootAndManifest = getProjectRootAndManifest;
function addMultichainManifestProjects(parentDir, multichainManifestContent, project) {
    for (const projectPath of multichainManifestContent.projects) {
        const { ext } = path_1.default.parse(projectPath);
        if (!extensionIsYamlOrJSON(ext)) {
            throw new Error(`Extension ${ext} not supported for project ${projectPath}`);
        }
        if (fs_1.default.existsSync(path_1.default.resolve(parentDir, projectPath))) {
            project.manifests.push(path_1.default.resolve(parentDir, projectPath));
        }
        else {
            throw new Error(`Project ${projectPath} not found`);
        }
    }
    if (project.manifests.length === 0) {
        throw new Error('None of the project files specified in the multichain manifest could be found');
    }
}
function getMultichainManifestPath(subquery) {
    const stats = fs_1.default.statSync(subquery);
    let multichainManifestPath;
    let projectRoot;
    if (stats.isDirectory()) {
        projectRoot = subquery;
        const multichainManifestCandidate = path_1.default.resolve(subquery, exports.DEFAULT_MULTICHAIN_MANIFEST);
        if (fs_1.default.existsSync(multichainManifestCandidate)) {
            multichainManifestPath = multichainManifestCandidate;
        }
    }
    else if (stats.isFile()) {
        const { dir, ext } = path_1.default.parse(subquery);
        projectRoot = dir;
        if (extensionIsYamlOrJSON(ext)) {
            const multichainManifestContent = yaml.load(fs_1.default.readFileSync(subquery, 'utf8'));
            if (multichainManifestContent.projects && Array.isArray(multichainManifestContent.projects)) {
                multichainManifestPath = path_1.default.resolve(dir, subquery);
            }
        }
    }
    if (multichainManifestPath && projectRoot) {
        return path_1.default.relative(projectRoot, multichainManifestPath);
    }
    return undefined;
}
exports.getMultichainManifestPath = getMultichainManifestPath;
function validateSemver(current, required) {
    return (0, semver_1.satisfies)(current, required, { includePrerelease: true });
}
exports.validateSemver = validateSemver;
let SemverVersionValidator = class SemverVersionValidator {
    validate(value) {
        if ((0, semver_1.valid)(value) === null) {
            return (0, semver_1.validRange)(value, { includePrerelease: false }) !== null;
        }
        else {
            return (0, semver_1.prerelease)(value || '') === null;
        }
    }
    defaultMessage(args) {
        return `'${args.value}' is not a valid version. Please provide a valid semver`;
    }
};
SemverVersionValidator = __decorate([
    (0, class_validator_1.ValidatorConstraint)({ name: 'semver', async: false })
], SemverVersionValidator);
exports.SemverVersionValidator = SemverVersionValidator;
async function delay(sec) {
    return new Promise((resolve) => {
        setTimeout(resolve, sec * 1000);
    });
}
exports.delay = delay;
function validateObject(object, errorMessage = 'failed to validate object.') {
    const errors = (0, class_validator_1.validateSync)(object, { whitelist: true, forbidNonWhitelisted: true });
    if (errors?.length) {
        const errorMsgs = errors.map((e) => e.toString()).join('\n');
        throw new Error(`${errorMessage}\n${errorMsgs}`);
    }
}
exports.validateObject = validateObject;
function extensionIsTs(ext) {
    return ext === '.ts';
}
exports.extensionIsTs = extensionIsTs;
function extensionIsYamlOrJSON(ext) {
    return ext === '.yaml' || ext === '.yml' || ext === '.json';
}
exports.extensionIsYamlOrJSON = extensionIsYamlOrJSON;
function forbidNonWhitelisted(keys, validationOptions) {
    return function (object, propertyName) {
        (0, class_validator_1.registerDecorator)({
            name: 'forbidNonWhitelisted',
            target: object.constructor,
            propertyName: propertyName,
            constraints: [],
            options: validationOptions,
            validator: {
                validate(value, args) {
                    const isValid = !Object.keys(value).some((key) => !(key in keys));
                    if (!isValid) {
                        throw new Error(`Invalid keys present in value: ${JSON.stringify(value)}. Whitelisted keys: ${JSON.stringify(Object.keys(keys))}`);
                    }
                    return isValid;
                },
            },
        });
    };
}
exports.forbidNonWhitelisted = forbidNonWhitelisted;
function notifyUpdates(pjson, logger) {
    const notifier = (0, update_notifier_1.default)({ pkg: pjson, updateCheckInterval: 0 });
    const latestVersion = notifier.update ? notifier.update.latest : pjson.version;
    if (notifier.update && (0, semver_1.lt)(pjson.version, latestVersion)) {
        logger.info(`Update available: ${pjson.version} â†’ ${latestVersion}`);
    }
    else {
        logger.info(`Current ${pjson.name} version is ${pjson.version}`);
    }
}
exports.notifyUpdates = notifyUpdates;
function toJsonObject(object) {
    // When using plainToInstance or plainToClass, Map types will need to be converted to a JSON object
    // https://github.com/typestack/class-transformer/issues/1256#issuecomment-1175153352
    return JSON.parse(JSON.stringify(object, (_, value) => {
        if (value instanceof Map) {
            return mapToObject(value);
        }
        return value;
    }));
}
exports.toJsonObject = toJsonObject;
function mapToObject(map) {
    // XXX can use Object.entries with newer versions of node.js
    const assetsObj = {};
    for (const key of map.keys()) {
        assetsObj[key] = map.get(key);
    }
    return assetsObj;
}
exports.mapToObject = mapToObject;
let FileReferenceImp = class FileReferenceImp {
    validate(value) {
        if (!value) {
            return false;
        }
        return !!Object.values(value).find((fileReference) => this.isValidFileReference(fileReference));
    }
    defaultMessage(args) {
        return `${JSON.stringify(args.value)} is not a valid assets format`;
    }
    isValidFileReference(fileReference) {
        return (fileReference &&
            typeof fileReference === 'object' &&
            'file' in fileReference &&
            typeof fileReference.file === 'string');
    }
};
FileReferenceImp = __decorate([
    (0, class_validator_1.ValidatorConstraint)({ name: 'isFileReference', async: false })
], FileReferenceImp);
exports.FileReferenceImp = FileReferenceImp;
const tsProjectYamlPath = (tsManifestEntry) => tsManifestEntry.replace('.ts', '.yaml');
exports.tsProjectYamlPath = tsProjectYamlPath;
let IsEndBlockGreater = class IsEndBlockGreater {
    validate(endBlock, args) {
        const object = args.object;
        return object.startBlock !== undefined && object.endBlock !== undefined
            ? object.endBlock >= object.startBlock
            : true;
    }
    defaultMessage(args) {
        return 'End block must be greater than or equal to start block';
    }
};
IsEndBlockGreater = __decorate([
    (0, class_validator_1.ValidatorConstraint)({ async: false })
], IsEndBlockGreater);
exports.IsEndBlockGreater = IsEndBlockGreater;
//# sourceMappingURL=utils.js.map