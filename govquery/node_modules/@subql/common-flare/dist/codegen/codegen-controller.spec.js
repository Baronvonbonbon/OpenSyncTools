"use strict";
// Copyright 2020-2024 SubQuery Pte Ltd authors & contributors
// SPDX-License-Identifier: GPL-3.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const types_flare_1 = require("@subql/types-flare");
const ejs_1 = __importDefault(require("ejs"));
const lodash_1 = require("lodash");
const rimraf_1 = __importDefault(require("rimraf"));
const codegen_controller_1 = require("./codegen-controller");
describe('Codegen spec', () => {
    const PROJECT_PATH = path_1.default.join(__dirname, '../../test/abiTest');
    it('ensure correct output when input does not contain []', () => {
        const mockAbiInterface = {
            type: 'function',
            name: 'initialize',
            inputs: [
                {
                    name: '__name',
                    type: 'STRING',
                },
            ],
        };
        expect((0, codegen_controller_1.joinInputAbiName)(mockAbiInterface)).toMatch('initialize_string_');
    });
    it('should replace [] in input abi name', () => {
        const mockAbiInterface = {
            type: 'function',
            name: 'initialize',
            inputs: [
                {
                    name: '__name',
                    type: 'string',
                },
                {
                    name: '__symbol',
                    type: 'string',
                },
                {
                    name: '__baseURI',
                    type: 'string',
                },
                {
                    name: 'admins',
                    type: 'address[]',
                },
            ],
        };
        expect((0, codegen_controller_1.joinInputAbiName)(mockAbiInterface)).toMatch('initialize_string_string_string_address_arr_');
    });
    it('json is object without abi field or empty abi json, should throw', () => {
        const artifactAssetObj = {
            artifact: './abis/bad-erc20.json',
        };
        expect(() => (0, codegen_controller_1.prepareAbiJob)(artifactAssetObj, PROJECT_PATH, (fp) => require(fp))).toThrow('Provided ABI is not a valid ABI or Artifact');
    });
    it('Empty abi json, should throw', () => {
        const projectPath = path_1.default.join(__dirname, '../../test/abiTest2');
        const artifactAssetObj = {
            artifact: './artifact.json',
        };
        expect(() => (0, codegen_controller_1.prepareAbiJob)(artifactAssetObj, projectPath, () => [])).toThrow('Invalid abi is provided at asset: artifact');
    });
    it('Should sort assets', () => {
        const ds = {
            kind: types_flare_1.EthereumDatasourceKind.Runtime,
            startBlock: 1,
            options: {
                abi: 'erc20',
                address: '',
            },
            assets: new Map([['erc20', { file: './abis/erc20.json' }]]),
            mapping: {
                file: '',
                handlers: [
                    {
                        handler: 'handleTransaction',
                        kind: types_flare_1.EthereumHandlerKind.Call,
                    },
                ],
            },
        };
        expect((0, codegen_controller_1.prepareSortedAssets)([ds], PROJECT_PATH)).toStrictEqual({ Erc20: './abis/erc20.json' });
    });
    it('Should sort assets with object', () => {
        const ds = {
            kind: types_flare_1.EthereumDatasourceKind.Runtime,
            startBlock: 1,
            options: {
                abi: 'erc20',
                address: '',
            },
            assets: new Map([['erc20', { file: './abis/erc20.json' }]]),
            mapping: {
                file: '',
                handlers: [
                    {
                        handler: 'handleTransaction',
                        kind: types_flare_1.EthereumHandlerKind.Call,
                    },
                ],
            },
        };
        expect((0, codegen_controller_1.prepareSortedAssets)([ds], PROJECT_PATH)).toStrictEqual({ Erc20: './abis/erc20.json' });
    });
    it('read artifact abis', () => {
        const projectPath = path_1.default.join(__dirname, '../../test/abiTest');
        const abisAssetObj = {
            Erc20: './abis/erc20.json',
        };
        const artifactAssetObj = {
            artifactErc20: './abis/Erc20.sol/Erc20.json',
        };
        const abisRendered = (0, codegen_controller_1.prepareAbiJob)(abisAssetObj, projectPath, (fp) => require(fp));
        const artifactRendered = (0, codegen_controller_1.prepareAbiJob)(artifactAssetObj, projectPath, (fp) => require(fp));
        // exclude name field
        artifactRendered.map((e) => {
            e.name = expect.any(String);
        });
        expect(abisRendered).toStrictEqual(expect.objectContaining(artifactRendered));
    });
    it('render correct codegen from ejs', async () => {
        const mockJob = {
            name: 'Erc20',
            events: ['Approval'],
            functions: [
                {
                    typename: 'approve',
                    functionName: 'approve',
                },
            ],
        };
        const data = await ejs_1.default.renderFile(path_1.default.resolve(__dirname, '../../templates/abi-interface.ts.ejs'), {
            props: { abi: mockJob },
            helper: { upperFirst: lodash_1.upperFirst },
        });
        await fs_1.default.promises.writeFile(path_1.default.join(PROJECT_PATH, 'test.ts'), data);
        const expectedCodegen = '' +
            '// SPDX-License-Identifier: Apache-2.0\n' +
            '\n' +
            '// Auto-generated , DO NOT EDIT\n' +
            'import {EthereumLog, EthereumTransaction, LightEthereumLog} from "@subql/types-flare";\n' +
            '\n' +
            "import {ApprovalEvent, Erc20} from '../contracts/Erc20'\n" +
            '\n' +
            '\n' +
            'export type ApprovalLog = EthereumLog<ApprovalEvent["args"]>\n' +
            '\n' +
            '\n' +
            'export type LightApprovalLog = LightEthereumLog<ApprovalEvent["args"]>\n' +
            '\n' +
            '\n' +
            "export type Transaction = EthereumTransaction<Parameters<Erc20['functions']['approve']>>";
        const output = await fs_1.default.promises.readFile(path_1.default.join(PROJECT_PATH, 'test.ts'));
        expect(output.toString()).toMatch(expectedCodegen);
        await (0, util_1.promisify)(rimraf_1.default)(path_1.default.join(PROJECT_PATH, 'test.ts'));
    });
    it('Correctness on getAbiNames', () => {
        expect((0, codegen_controller_1.getAbiNames)(['Erc721__factory.ts', 'Erc1155__factory.ts', 'index.ts'])).toStrictEqual(['Erc721', 'Erc1155']);
    });
    it('Generate correct restructured index.ts', async () => {
        const mockAbiNames = ['Erc721', 'Erc1155', 'Erc1967'];
        const contractsData = await ejs_1.default.renderFile(path_1.default.resolve(__dirname, '../../templates/contracts-index.ts.ejs'), {
            props: { abiNames: mockAbiNames },
        });
        const factoriesData = await ejs_1.default.renderFile(path_1.default.resolve(__dirname, '../../templates/factories-index.ts.ejs'), {
            props: { abiNames: mockAbiNames },
        });
        await Promise.all([
            fs_1.default.promises.writeFile(path_1.default.join(PROJECT_PATH, 'contracts-index.ts'), contractsData),
            fs_1.default.promises.writeFile(path_1.default.join(PROJECT_PATH, 'factories-index.ts'), factoriesData),
        ]);
        const contractOutput = await fs_1.default.promises.readFile(path_1.default.join(PROJECT_PATH, 'contracts-index.ts'));
        const factoriesOutput = await fs_1.default.promises.readFile(path_1.default.join(PROJECT_PATH, 'factories-index.ts'));
        expect(contractOutput.toString()).toBe('' +
            '/* Autogenerated file. Do not edit manually. */\n' +
            '/* tslint:disable */\n' +
            '/* eslint-disable */\n' +
            'export * as factories from "./factories";\n' +
            '\n' +
            'export { Erc721 } from "./Erc721";\n' +
            '\n' +
            'export { Erc1155 } from "./Erc1155";\n' +
            '\n' +
            'export { Erc1967 } from "./Erc1967";\n' +
            '\n' +
            '\n' +
            'export { Erc721__factory } from "./factories/Erc721__factory";\n' +
            '\n' +
            'export { Erc1155__factory } from "./factories/Erc1155__factory";\n' +
            '\n' +
            'export { Erc1967__factory } from "./factories/Erc1967__factory";\n');
        expect(factoriesOutput.toString()).toBe('' +
            '/* Autogenerated file. Do not edit manually. */\n' +
            '/* tslint:disable */\n' +
            '/* eslint-disable */\n' +
            '\n' +
            '\n' +
            'export { Erc721__factory } from "./Erc721__factory";\n' +
            '\n' +
            'export { Erc1155__factory } from "./Erc1155__factory";\n' +
            '\n' +
            'export { Erc1967__factory } from "./Erc1967__factory";\n');
        await Promise.all([
            (0, util_1.promisify)(rimraf_1.default)(path_1.default.join(PROJECT_PATH, 'contracts-index.ts')),
            (0, util_1.promisify)(rimraf_1.default)(path_1.default.join(PROJECT_PATH, 'factories-index.ts')),
        ]);
    });
    it('Generates valid function names with complex types', () => {
        const artifactAssetObj = {
            artifact: './abis/contract_with_overloads.json',
        };
        const [props] = (0, codegen_controller_1.prepareAbiJob)(artifactAssetObj, PROJECT_PATH, (fp) => require(fp));
        expect(props.functions[4].functionName).toEqual('deregisterOperatorWithCoordinator(bytes,(uint256,uint256))');
        expect(props.functions[27].functionName).toEqual('registerOperatorWithCoordinator(bytes,(uint256,uint256),string,(uint8,address,(uint256,uint256))[],(bytes,bytes32,uint256))');
    });
    it('validate Abi.json path field', async () => {
        const ds = {
            kind: types_flare_1.EthereumDatasourceKind.Runtime,
            startBlock: 1,
            options: {
                abi: 'erc20',
                address: '',
            },
            assets: new Map([['erc20', { file: './abis/xxx.json' }]]),
            mapping: {
                file: '',
                handlers: [
                    {
                        handler: 'handleTransaction',
                        kind: types_flare_1.EthereumHandlerKind.Call,
                        filter: {
                            function: 'transfer()',
                        },
                    },
                ],
            },
        };
        await expect((0, codegen_controller_1.generateAbis)([ds], PROJECT_PATH, undefined, undefined, undefined)).rejects.toThrow(/Asset: "erc20" not found in project/);
    });
    it('validate Abi.json Function Not Exist', async () => {
        const ds = {
            kind: types_flare_1.EthereumDatasourceKind.Runtime,
            startBlock: 1,
            options: {
                abi: 'erc20',
                address: '',
            },
            assets: new Map([['erc20', { file: './abis/erc20.json' }]]),
            mapping: {
                file: '',
                handlers: [
                    {
                        handler: 'handleTransaction',
                        kind: types_flare_1.EthereumHandlerKind.Call,
                        filter: {
                            function: 'approve(address a,uint256 b)',
                        },
                    },
                    {
                        handler: 'handleTransaction',
                        kind: types_flare_1.EthereumHandlerKind.Call,
                        filter: {
                            function: 'approve222(address a,uint256 b)',
                        },
                    },
                ],
            },
        };
        await expect((0, codegen_controller_1.generateAbis)([ds], PROJECT_PATH, undefined, undefined, undefined)).rejects.toThrow(/Function: "approve222\(address a,uint256 b\)" not found in erc20 contract interface/);
    });
    it('validate Abi.json Topic Not Exist', async () => {
        const ds = {
            kind: types_flare_1.EthereumDatasourceKind.Runtime,
            startBlock: 1,
            options: {
                abi: 'erc20',
                address: '',
            },
            assets: new Map([['erc20', { file: './abis/erc20.json' }]]),
            mapping: {
                file: '',
                handlers: [
                    {
                        handler: 'handleTransaction',
                        kind: types_flare_1.EthereumHandlerKind.Event,
                        filter: {
                            topics: ['Transfer(address a,address b,uint256 c)'],
                        },
                    },
                    {
                        handler: 'handleTransaction',
                        kind: types_flare_1.EthereumHandlerKind.Event,
                        filter: {
                            topics: ['Transfer(address a,address b,uint256 c)', 'NotExist(address a)'],
                        },
                    },
                ],
            },
        };
        await expect((0, codegen_controller_1.generateAbis)([ds], PROJECT_PATH, undefined, undefined, undefined)).rejects.toThrow(/Topic: "NotExist\(address a\)" not found in erc20 contract interface/);
    });
    it('doesnt validate if datasource has no abi option set', async () => {
        const ds = {
            kind: types_flare_1.EthereumDatasourceKind.Runtime,
            startBlock: 1,
            assets: new Map([['erc20', { file: './abis/erc20.json' }]]),
            mapping: {
                file: '',
                handlers: [
                    {
                        handler: 'handleTransaction',
                        kind: types_flare_1.EthereumHandlerKind.Event,
                        filter: {
                            topics: ['Transfer(address a,address b,uint256 c)'],
                        },
                    },
                    {
                        handler: 'handleTransaction',
                        kind: types_flare_1.EthereumHandlerKind.Event,
                        filter: {
                            topics: ['Transfer(address a,address b,uint256 c)', 'NotExist(address a)'],
                        },
                    },
                ],
            },
        };
        await expect((0, codegen_controller_1.generateAbis)([ds], PROJECT_PATH, (p) => Promise.resolve(), (v) => v, () => Promise.resolve())).resolves.not.toThrow();
    });
});
//# sourceMappingURL=codegen-controller.spec.js.map