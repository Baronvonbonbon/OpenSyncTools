"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getServiceImplement = exports.buildImports = exports.ToWindowsPath = exports.ToUnixPath = exports.convertIfWinPath = exports.getTypeNameFromFieldName = exports.getPluginValue = exports.swapKeyValue = void 0;
const minimatch_1 = __importDefault(require("minimatch"));
const dotty = __importStar(require("dotty"));
const os_1 = __importDefault(require("os"));
/**
 * swap the key and value of the input object
 * @param input obj needs to swap
 * @returns swapped obj
 */
const swapKeyValue = (input) => {
    const output = {};
    for (const key in input) {
        if (input.hasOwnProperty(key)) {
            output[input[key]] = key;
        }
    }
    return output;
};
exports.swapKeyValue = swapKeyValue;
const getAllPackageParts = (name, list) => {
    if (!list)
        list = [name];
    const newParts = name.split(".");
    newParts.pop();
    if (!newParts.length)
        return [...list];
    const newName = newParts.join(".");
    return getAllPackageParts(newName, [...list, newName]);
};
const getPluginValue = (optionName, currentPkg, options) => {
    const pkgOpts = options.packages;
    let value;
    if (currentPkg) {
        getAllPackageParts(currentPkg).some((pkg, i) => {
            if (dotty.exists(pkgOpts, pkg)) {
                const obj = dotty.get(pkgOpts, pkg);
                if (dotty.exists(obj, optionName)) {
                    value = dotty.get(obj, optionName);
                    return true;
                }
            }
        });
    }
    if (value === undefined) {
        const defaultValue = dotty.exists(options, optionName)
            ? dotty.get(options, optionName)
            : undefined;
        value = defaultValue;
    }
    return value;
};
exports.getPluginValue = getPluginValue;
const getTypeNameFromFieldName = (name, importSrc, ref) => {
    let importedAs = name;
    const names = ref.traversed?.importNames;
    if (names &&
        names.hasOwnProperty(importSrc) &&
        names[importSrc].hasOwnProperty(name)) {
        importedAs = names[importSrc][name];
    }
    return importedAs;
};
exports.getTypeNameFromFieldName = getTypeNameFromFieldName;
const convertIfWinPath = (reg, replaceValue, path) => {
    if (os_1.default.platform() === 'win32') {
        return path.replace(reg, replaceValue);
    }
    return path;
};
exports.convertIfWinPath = convertIfWinPath;
exports.ToUnixPath = /\\/g;
exports.ToWindowsPath = /\//g;
const buildImports = (imports) => {
    return imports.map((item) => {
        return {
            type: "ImportDeclaration",
            importKind: "value",
            specifiers: [
                {
                    type: "ImportNamespaceSpecifier",
                    local: {
                        type: "Identifier",
                        name: item.importedAs,
                    },
                },
            ],
            source: {
                type: "StringLiteral",
                value: item.import,
            },
        };
    });
};
exports.buildImports = buildImports;
// https://github.com/isaacs/minimatch/blob/main/src/index.ts#L61
// Optimized checking for the most common glob patterns.
const globPattern = /\*+([^+@!?\*\[\(]*)/;
const getServiceImplement = (serviceName, packagePath, methodName, serviceImplement) => {
    if (serviceImplement) {
        const implement = serviceImplement[serviceName];
        if (implement) {
            const methodNameWithPkg = `${packagePath}.${methodName}`;
            const isMatching = !implement.include?.patterns?.length ||
                implement.include.patterns.some((pattern) => {
                    if (!globPattern.test(pattern)) {
                        return methodNameWithPkg === pattern;
                    }
                    return (0, minimatch_1.default)(methodNameWithPkg, pattern);
                });
            if (isMatching) {
                return implement.type;
            }
            else {
                return undefined;
            }
        }
    }
    return undefined;
};
exports.getServiceImplement = getServiceImplement;
