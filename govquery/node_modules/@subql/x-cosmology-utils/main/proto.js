"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getObjectName = exports.isRefExcluded = exports.isRefIncluded = exports.getQueryMethodNames = exports.makeHookKeyName = exports.makeUseHookTypeName = exports.makePkgMethodName = exports.makeUsePkgHookName = exports.makeUseHookNameWithCamel = exports.makeUseHookName = exports.getNested = exports.getNestedProtoGeneric = exports.getNestedProto = void 0;
const _1 = require(".");
const case_1 = require("case");
const minimatch_1 = __importDefault(require("minimatch"));
const dotty_1 = __importDefault(require("dotty"));
const getNestedProto = (root) => {
    const nestedPath = "root.nested." + root.package.split(".").join(".nested.") + ".nested";
    return dotty_1.default.get(root, nestedPath);
};
exports.getNestedProto = getNestedProto;
const getNestedProtoGeneric = (root, path) => {
    path = root.package.split(".").concat(path);
    const nestedPath = "root.nested." + path.join(".nested.") + ".nested";
    return dotty_1.default.get(root, nestedPath);
};
exports.getNestedProtoGeneric = getNestedProtoGeneric;
const getNested = (root, path) => {
    const nestedPath = "root.nested." + path.join(".nested.") + ".nested";
    return dotty_1.default.get(root, nestedPath);
};
exports.getNested = getNested;
/**
 * to make a customized hook name.
 * e.g. snake_case -> useSnakeCase.
 *      Snake -> use_Snake (be more careful on this case)
 *      snake_Case -> useSnake_Case (be more careful on this case)
 * There're some wierd cases because of the camel function only replaces lower case letters leading with '_' to upper case.
 * @param name base name without the word 'use'
 * @returns customized hook name like 'useSth'
 */
const makeUseHookName = (name) => {
    return (0, _1.camel)("use_" + name);
};
exports.makeUseHookName = makeUseHookName;
const makeUseHookNameWithCamel = (name) => {
    return (0, _1.camel)("use_" + (0, _1.camel)(name));
};
exports.makeUseHookNameWithCamel = makeUseHookNameWithCamel;
const makeUsePkgHookName = (packageName, name) => {
    return (0, _1.variableSlug)(`use_${packageName.replace(/\./g, "_")}_${(0, case_1.snake)(name)}`);
};
exports.makeUsePkgHookName = makeUsePkgHookName;
const makePkgMethodName = (packageName, name) => {
    return (0, _1.variableSlug)(`pkg_${packageName.replace(/\./g, "_")}_${(0, case_1.snake)(name)}`);
};
exports.makePkgMethodName = makePkgMethodName;
const makeUseHookTypeName = (name) => {
    return (0, case_1.pascal)("Use_" + name + "Query");
};
exports.makeUseHookTypeName = makeUseHookTypeName;
const makeHookKeyName = (name) => {
    return (0, _1.camel)(name + "Query");
};
exports.makeHookKeyName = makeHookKeyName;
// https://github.com/isaacs/minimatch/blob/main/src/index.ts#L61
// Optimized checking for the most common glob patterns.
const globPattern = /\*+([^+@!?\*\[\(]*)/;
/**
 * Get a list of query method names that matches the given patterns.
 * @param packagePath package path like 'cosmos.bank.v1beta1'
 * @param methodKeys query method names
 * @param patterns minimatch pattern like 'cosmos.auth.**'
 * @returns Array of query method names match the given pattern.
 */
const getQueryMethodNames = (packagePath, methodKeys, patterns, makeMethodName) => {
    const make = makeMethodName ?? exports.makeUseHookNameWithCamel;
    return methodKeys
        .map((key) => {
        const methodName = make(key);
        const methodNameWithPkg = `${packagePath}.${methodName}`;
        const isMatching = patterns &&
            patterns.some((pattern) => {
                if (!globPattern.test(pattern)) {
                    return methodNameWithPkg === pattern;
                }
                return (0, minimatch_1.default)(methodNameWithPkg, pattern);
            });
        if (isMatching) {
            return key;
        }
        else {
            return null;
        }
    })
        .filter(Boolean);
};
exports.getQueryMethodNames = getQueryMethodNames;
/**
 * test if a proto ref is included by the operation.
 * @param ref a ProtoRef with proto file info and package.
 * @param include patterns(will be deprecated soon), packages, proto files to include
 * @returns
 */
const isRefIncluded = (ref, include) => {
    // if no include object, no filter
    if (!include)
        return true;
    // if no arrays are populated, no filter
    if (!include.patterns?.length &&
        !include.packages?.length &&
        !include.protos?.length) {
        return true;
    }
    // TODO consider deprecating `patterns` in favor of packages and protos supporting minimatch
    if (Boolean(ref.filename) && include?.patterns?.some(pattern => (0, minimatch_1.default)(ref.filename, pattern))) {
        return true;
    }
    const pkgMatched = Boolean(ref.proto?.package) && include?.packages?.some(pkgName => {
        if (!globPattern.test(pkgName)) {
            return ref.proto.package === pkgName;
        }
        return (0, minimatch_1.default)(ref.proto.package, pkgName);
    });
    if (pkgMatched) {
        return true;
    }
    const protoMatched = Boolean(ref.filename) && include?.protos?.some(protoName => {
        if (!globPattern.test(protoName)) {
            return ref.filename === protoName;
        }
        return (0, minimatch_1.default)(ref.filename, protoName);
    });
    if (protoMatched) {
        return true;
    }
    return false;
};
exports.isRefIncluded = isRefIncluded;
/**
 * test if a proto ref is excluded from the operation.
 * @param ref a ProtoRef with proto file info and package.
 * @param exclude patterns(will be deprecated soon), packages, proto files to exclude
 * @returns
 */
const isRefExcluded = (ref, exclude) => {
    // if no include object, no filter
    if (!exclude)
        return false;
    // if no arrays are populated, no filter
    if (!exclude.packages?.length &&
        !exclude.protos?.length) {
        return false;
    }
    return (0, exports.isRefIncluded)(ref, exclude);
};
exports.isRefExcluded = isRefExcluded;
/*
    nested objects get a slightly different naming convention
    e.g. SignatureDescriptor_Data or SignatureDescriptor_Data_Multi
*/
const getObjectName = (name, scope = []) => {
    if (!scope.length || scope.length === 1)
        return name;
    const [_pkg, ...scopes] = scope;
    return [...scopes, name].join('_');
};
exports.getObjectName = getObjectName;
