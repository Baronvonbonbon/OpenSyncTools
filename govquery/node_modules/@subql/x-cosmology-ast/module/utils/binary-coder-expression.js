import * as t from '@babel/types';
export const BinaryCoder = {
    addUtil: (ctx, type) => {
        if (!ctx) {
            return;
        }
        const longLib = ctx.pluginValue('prototypes.typingsFormat.num64');
        type = type?.trim().toLowerCase();
        switch (longLib) {
            case 'long':
                ctx.addUtil('_m0');
                break;
            case 'bigint':
                if (!type || type === 'both' || type === 'reader') {
                    ctx.addUtil('BinaryReader');
                }
                if (!type || type === 'both' || type === 'writer') {
                    ctx.addUtil('BinaryWriter');
                }
                break;
        }
    },
    getNode: (ctx, mappings) => {
        const longLib = ctx.pluginValue('prototypes.typingsFormat.num64');
        return mappings[longLib] ?? mappings['long'];
    },
    readerMemberExp: {
        bigint: t.identifier('BinaryReader'),
        long: t.memberExpression(t.identifier('_m0'), t.identifier('Reader'))
    },
    writerMemberExp: {
        bigint: t.identifier('BinaryWriter'),
        long: t.memberExpression(t.identifier('_m0'), t.identifier('Writer'))
    },
    readerTypeRef: {
        bigint: t.tsTypeReference(t.identifier('BinaryReader')),
        long: t.tsTypeReference(t.tsQualifiedName(t.identifier('_m0'), t.identifier('Reader')), null)
    },
    writerTypeRef: {
        bigint: t.tsTypeReference(t.identifier('BinaryWriter')),
        long: t.tsTypeReference(t.tsQualifiedName(t.identifier('_m0'), t.identifier('Writer')), null)
    },
    getReaderMemberExp: (ctx) => {
        return BinaryCoder.getNode(ctx, BinaryCoder.readerMemberExp);
    },
    getWriterMemberExp: (ctx) => {
        return BinaryCoder.getNode(ctx, BinaryCoder.writerMemberExp);
    },
    getReaderTypeRef: (ctx) => {
        return BinaryCoder.getNode(ctx, BinaryCoder.readerTypeRef);
    },
    getWriterTypeRef: (ctx) => {
        return BinaryCoder.getNode(ctx, BinaryCoder.writerTypeRef);
    }
};
