"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toAminoJsonMethod = exports.toAminoParseField = void 0;
const t = __importStar(require("@babel/types"));
const utils_1 = require("../../../utils");
const utils_2 = require("../utils");
const utils_3 = require("./utils");
const proto_1 = require("../../proto");
const needsImplementation = (name, field) => {
    throw new Error(`need to implement toAmino (${field.type} rules[${field.rule}] name[${name}])`);
};
const warningDefaultImplementation = (name, field) => {
    console.warn(`need to implement toAmino (${field.type} rules[${field.rule}] name[${name}])`);
};
;
const toAminoParseField = ({ context, field, currentProtoPath, scope: previousScope, fieldPath: previousFieldPath, nested, isOptional }) => {
    const scope = [field.name, ...previousScope];
    const fieldPath = [field, ...previousFieldPath];
    const args = {
        context,
        field,
        currentProtoPath,
        scope,
        fieldPath,
        nested,
        isOptional
    };
    // arrays
    if (field.rule === 'repeated') {
        switch (field.type) {
            case 'string':
                return utils_3.toAmino.stringArray(args);
            case 'int64':
            case 'sint64':
            case 'uint64':
            case 'fixed64':
            case 'sfixed64':
                return utils_3.toAmino.scalarArray(args, utils_3.arrayTypes.long);
            case 'double':
            case 'float':
            case 'int32':
            case 'sint32':
            case 'uint32':
            case 'fixed32':
            case 'sfixed32':
            case 'bool':
            case 'bytes':
                return utils_3.toAmino.defaultType(args);
            case 'string':
                return utils_3.toAmino.string(args);
        }
        switch (field.parsedType.type) {
            case 'Enum':
                return utils_3.toAmino.defaultType(args);
            case 'Type':
                return utils_3.toAmino.typeArray(args);
        }
        return needsImplementation(field.name, field);
    }
    // casting Any types
    if (field.type === 'google.protobuf.Any') {
        switch (field.options?.['(cosmos_proto.accepts_interface)']) {
            case 'cosmos.crypto.PubKey':
                return utils_3.toAmino.pubkey(args);
        }
    }
    // special types...
    switch (field.type) {
        case 'Timestamp':
        case 'google.protobuf.Timestamp':
            return utils_3.toAmino.defaultType(args);
        case 'cosmos.base.v1beta1.Coin':
            return utils_3.toAmino.coin(args);
        // TODO check can we just
        // make pieces optional and avoid hard-coding this type?
        case 'ibc.core.client.v1.Height':
        case 'Height':
            return utils_3.toAmino.height(args);
        case 'Duration':
        case 'google.protobuf.Duration':
            return utils_3.toAmino.duration(args);
        default:
    }
    // Types/Enums
    switch (field.parsedType.type) {
        case 'Enum':
            return utils_3.toAmino.defaultType(args);
        case 'Type':
            return utils_3.toAmino.type(args);
    }
    if (field.type === 'bytes') {
        // bytes [RawContractMessage]
        if (field.options?.['(gogoproto.casttype)'] === 'RawContractMessage') {
            return utils_3.toAmino.rawBytes(args);
        }
        // bytes [WASMByteCode]
        // TODO use a better option for this in proto source
        if (field.options?.['(gogoproto.customname)'] === 'WASMByteCode') {
            return utils_3.toAmino.wasmByteCode(args);
        }
    }
    // scalar types...
    switch (field.type) {
        case 'string':
            return utils_3.toAmino.string(args);
        case 'int64':
        case 'sint64':
        case 'uint64':
        case 'fixed64':
        case 'sfixed64':
            return utils_3.toAmino.long(args);
        case 'double':
        case 'float':
        case 'int32':
        case 'sint32':
        case 'uint32':
        case 'fixed32':
        case 'sfixed32':
        case 'bool':
        case 'bytes':
            return utils_3.toAmino.defaultType(args);
        default:
            warningDefaultImplementation(field.name, field);
            return utils_3.toAmino.defaultType(args);
    }
};
exports.toAminoParseField = toAminoParseField;
const toAminoJsonMethod = ({ context, proto }) => {
    const toAminoParams = t.objectPattern((0, utils_2.protoFieldsToArray)(proto).map((field) => t.objectProperty(t.identifier(field.name), t.identifier(field.name), false, true)));
    toAminoParams.typeAnnotation = t.tsTypeAnnotation(t.tsTypeReference(t.identifier(proto.name)));
    const oneOfs = (0, proto_1.getOneOfs)(proto);
    const fields = (0, utils_2.protoFieldsToArray)(proto).map((field) => {
        const isOneOf = oneOfs.includes(field.name);
        const isOptional = (0, proto_1.getFieldOptionality)(context, field, isOneOf);
        const aminoField = (0, exports.toAminoParseField)({
            context,
            field,
            currentProtoPath: context.ref.filename,
            scope: [],
            fieldPath: [],
            nested: 0,
            isOptional
        });
        return {
            ctx: context,
            field: aminoField
        };
    });
    // const ctxs = fields.map(({ ctx }) => ctx);
    // ctxs.forEach(ctx => {
    //     // console.log('imports, ', ctx)
    // })
    return (0, utils_1.arrowFunctionExpression)([
        toAminoParams
    ], t.blockStatement([
        t.returnStatement(t.objectExpression(fields.map(({ field }) => field)))
    ]), t.tsTypeAnnotation(t.tsIndexedAccessType(t.tsTypeReference(t.identifier(proto.name + 'AminoType')), t.tsLiteralType(t.stringLiteral('value')))));
};
exports.toAminoJsonMethod = toAminoJsonMethod;
