"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromPartialMethod = exports.fromPartialMethodFields = void 0;
const t = __importStar(require("@babel/types"));
const __1 = require("..");
const utils_1 = require("../../../utils");
const types_1 = require("../types");
const utils_2 = require("./utils");
const needsImplementation = (name, field) => {
    throw new Error(`need to implement fromPartial (${field.type} rules[${field.rule}] name[${name}])`);
};
const fromPartialMethodFields = (context, name, proto) => {
    const oneOfs = (0, __1.getOneOfs)(proto);
    const fields = Object.keys(proto.fields ?? {}).map(fieldName => {
        const field = {
            name: fieldName,
            ...proto.fields[fieldName]
        };
        const isOneOf = oneOfs.includes(fieldName);
        const isOptional = (0, __1.getFieldOptionality)(context, field, isOneOf);
        const args = {
            context,
            field,
            isOneOf,
            isOptional
        };
        if (field.rule === 'repeated') {
            switch (field.type) {
                case 'string':
                    return utils_2.fromPartial.array(args, utils_2.arrayTypes.string());
                case 'bool':
                    return utils_2.fromPartial.array(args, utils_2.arrayTypes.bool());
                case 'bytes':
                    return utils_2.fromPartial.array(args, utils_2.arrayTypes.bytes());
                case 'float':
                    return utils_2.fromPartial.array(args, utils_2.arrayTypes.float());
                case 'double':
                    return utils_2.fromPartial.array(args, utils_2.arrayTypes.double());
                case 'int32':
                    return utils_2.fromPartial.array(args, utils_2.arrayTypes.int32());
                case 'sint32':
                    return utils_2.fromPartial.array(args, utils_2.arrayTypes.sint32());
                case 'uint32':
                    return utils_2.fromPartial.array(args, utils_2.arrayTypes.uint32());
                case 'fixed32':
                    return utils_2.fromPartial.array(args, utils_2.arrayTypes.fixed32());
                case 'sfixed32':
                    return utils_2.fromPartial.array(args, utils_2.arrayTypes.sfixed32());
                case 'int64':
                    return utils_2.fromPartial.array(args, utils_2.arrayTypes.int64(args));
                case 'sint64':
                    return utils_2.fromPartial.array(args, utils_2.arrayTypes.sint64(args));
                case 'uint64':
                    return utils_2.fromPartial.array(args, utils_2.arrayTypes.uint64(args));
                case 'fixed64':
                    return utils_2.fromPartial.array(args, utils_2.arrayTypes.fixed64(args));
                case 'sfixed64':
                    return utils_2.fromPartial.array(args, utils_2.arrayTypes.sfixed64(args));
                default:
                    switch (field.parsedType.type) {
                        case 'Enum':
                            return utils_2.fromPartial.array(args, utils_2.arrayTypes.enum());
                        case 'Type':
                            return utils_2.fromPartial.array(args, utils_2.arrayTypes.type(args));
                    }
                    return needsImplementation(fieldName, field);
            }
        }
        if (field.keyType) {
            switch (field.keyType) {
                case 'string':
                case 'int32':
                case 'sint32':
                case 'uint32':
                case 'fixed32':
                case 'sfixed32':
                case 'int64':
                case 'sint64':
                case 'uint64':
                case 'fixed64':
                case 'sfixed64':
                    return utils_2.fromPartial.keyHash(args);
                default:
                    return needsImplementation(fieldName, field);
            }
        }
        switch (field.type) {
            case 'string':
                return utils_2.fromPartial.string(args);
            case 'bytes':
                return utils_2.fromPartial.bytes(args);
            case 'bool':
                return utils_2.fromPartial.bool(args);
            case 'double':
                return utils_2.fromPartial.double(args);
            case 'float':
                return utils_2.fromPartial.float(args);
            case 'int32':
                return utils_2.fromPartial.int32(args);
            case 'sint32':
                return utils_2.fromPartial.sint32(args);
            case 'uint32':
                return utils_2.fromPartial.uint32(args);
            case 'fixed32':
                return utils_2.fromPartial.fixed32(args);
            case 'sfixed32':
                return utils_2.fromPartial.sfixed32(args);
            case 'int64':
                return utils_2.fromPartial.int64(args);
            case 'sint64':
                return utils_2.fromPartial.sint64(args);
            case 'uint64':
                return utils_2.fromPartial.uint64(args);
            case 'fixed64':
                return utils_2.fromPartial.fixed64(args);
            case 'sfixed64':
                return utils_2.fromPartial.sfixed64(args);
            // TODO: handle Date and Duration choices
            case 'google.protobuf.Duration':
            case 'Duration':
                return utils_2.fromPartial.duration(args);
            case 'google.protobuf.Timestamp':
            case 'Timestamp':
                return utils_2.fromPartial.timestamp(args);
            default:
                switch (field.parsedType.type) {
                    case 'Enum':
                        return utils_2.fromPartial.enum(args);
                    case 'Type':
                        return utils_2.fromPartial.type(args);
                }
                return needsImplementation(fieldName, field);
        }
    });
    return fields;
};
exports.fromPartialMethodFields = fromPartialMethodFields;
const fromPartialMethod = (context, name, proto) => {
    const useDeepPartial = context.pluginValue('prototypes.typingsFormat.useDeepPartial');
    let partialName = 'Partial';
    if (useDeepPartial) {
        context.addUtil('DeepPartial');
        partialName = 'DeepPartial';
    }
    const fields = (0, exports.fromPartialMethodFields)(context, name, proto);
    let varName = 'object';
    if (!fields.length) {
        varName = '_';
    }
    let typeParameters = undefined;
    let param = null;
    const useExact = context.pluginValue('prototypes.typingsFormat.useExact');
    if (useExact === true) {
        context.addUtil('Exact');
        // type params
        typeParameters = t.tsTypeParameterDeclaration([
            t.tsTypeParameter(t.tsTypeReference(t.identifier('Exact'), t.tsTypeParameterInstantiation([
                t.tsTypeReference(t.identifier(partialName), t.tsTypeParameterInstantiation([
                    t.tsTypeReference(t.identifier(name))
                ])),
                t.tsTypeReference(t.identifier('I'))
            ])), null, 'I')
        ]);
        // param
        param = (0, utils_1.identifier)(varName, t.tsTypeAnnotation(t.tsTypeReference(t.identifier('I'))));
    }
    else {
        // param
        param = (0, utils_1.identifier)(varName, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(partialName), t.tsTypeParameterInstantiation([
            t.tsTypeReference(t.identifier(name))
        ]))));
    }
    return (0, utils_1.objectMethod)('method', t.identifier('fromPartial'), [
        param
    ], t.blockStatement([
        // init
        t.variableDeclaration('const', [
            t.variableDeclarator(t.identifier('message'), t.callExpression(t.identifier((0, types_1.getBaseCreateTypeFuncName)(name)), []))
        ]),
        ...fields,
        // RETURN
        t.returnStatement(t.identifier('message'))
    ]), false, false, false, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(name))), typeParameters);
};
exports.fromPartialMethod = fromPartialMethod;
