"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toAminoMsgMethod = exports.toAminoJSONMethod = exports.toAminoJSONMethodFields = void 0;
const t = __importStar(require("@babel/types"));
const __1 = require("..");
const utils_1 = require("../../../utils");
const utils_2 = require("./utils");
const types_1 = require("../../types");
const amino_1 = require("../../amino");
const needsImplementation = (name, field) => {
    throw new Error(`need to implement toAminoJSON (${field.type} rules[${field.rule}] name[${name}])`);
};
const toAminoJSONMethodFields = (context, name, proto) => {
    const oneOfs = (0, __1.getOneOfs)(proto);
    const fields = Object.keys(proto.fields ?? {}).reduce((m, fieldName) => {
        const field = {
            name: fieldName,
            ...proto.fields[fieldName]
        };
        const isOneOf = oneOfs.includes(fieldName);
        const isOptional = (0, __1.getFieldOptionalityForAmino)(context, field, isOneOf);
        const args = {
            context,
            field,
            isOneOf,
            isOptional
        };
        // arrays
        if (field.rule === 'repeated') {
            switch (field.type) {
                case 'string':
                    return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.string(args))];
                case 'bytes':
                    return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.bytes(args))];
                case 'bool':
                    return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.bool())];
                case 'double':
                    return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.double())];
                case 'float':
                    return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.float())];
                case 'int32':
                    return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.int32())];
                case 'sint32':
                    return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.sint32())];
                case 'uint32':
                    return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.uint32())];
                case 'fixed32':
                    return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.fixed32())];
                case 'sfixed32':
                    return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.sfixed32())];
                case 'int64':
                    return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.int64(args))];
                case 'sint64':
                    return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.sint64(args))];
                case 'uint64':
                    return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.uint64(args))];
                case 'fixed64':
                    return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.fixed64(args))];
                case 'sfixed64':
                    return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.sfixed64(args))];
                default:
                    switch (field.parsedType.type) {
                        case 'Enum':
                            return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.enum(args))];
                        case 'Type':
                            return [...m, utils_2.toAminoJSON.array(args, utils_2.arrayTypes.type(args))];
                    }
                    return needsImplementation(fieldName, field);
            }
        }
        if (field.keyType) {
            switch (field.keyType) {
                case 'string':
                case 'int32':
                case 'sint32':
                case 'uint32':
                case 'fixed32':
                case 'sfixed32':
                case 'int64':
                case 'sint64':
                case 'uint64':
                case 'fixed64':
                case 'sfixed64':
                    return [...m, ...utils_2.toAminoJSON.keyHash(args)];
                default:
                    return needsImplementation(fieldName, field);
            }
        }
        // casting Any types
        if (field.type === 'google.protobuf.Any') {
            switch (field.options?.['(cosmos_proto.accepts_interface)']) {
                case 'cosmos.crypto.PubKey':
                    return [...m, utils_2.toAminoJSON.pubkey(args)];
            }
        }
        if (field.type === 'bytes') {
            // bytes [RawContractMessage]
            if (field.options?.['(gogoproto.casttype)'] === 'RawContractMessage') {
                return [...m, utils_2.toAminoJSON.rawBytes(args)];
            }
            // bytes [WASMByteCode]
            // TODO use a better option for this in proto source
            if (field.options?.['(gogoproto.customname)'] === 'WASMByteCode') {
                return [...m, utils_2.toAminoJSON.wasmByteCode(args)];
            }
        }
        // default types
        switch (field.type) {
            case 'string':
                return [...m, utils_2.toAminoJSON.string(args)];
            case 'double':
                return [...m, utils_2.toAminoJSON.double(args)];
            case 'float':
                return [...m, utils_2.toAminoJSON.float(args)];
            case 'bytes':
                return [...m, utils_2.toAminoJSON.bytes(args)];
            case 'bool':
                return [...m, utils_2.toAminoJSON.bool(args)];
            case 'int32':
                return [...m, utils_2.toAminoJSON.int32(args)];
            case 'sint32':
                return [...m, utils_2.toAminoJSON.sint32(args)];
            case 'uint32':
                return [...m, utils_2.toAminoJSON.uint32(args)];
            case 'fixed32':
                return [...m, utils_2.toAminoJSON.fixed32(args)];
            case 'sfixed32':
                return [...m, utils_2.toAminoJSON.sfixed32(args)];
            case 'int64':
                return [...m, utils_2.toAminoJSON.int64(args)];
            case 'sint64':
                return [...m, utils_2.toAminoJSON.sint64(args)];
            case 'uint64':
                return [...m, utils_2.toAminoJSON.uint64(args)];
            case 'fixed64':
                return [...m, utils_2.toAminoJSON.fixed64(args)];
            case 'sfixed64':
                return [...m, utils_2.toAminoJSON.sfixed64(args)];
            case 'google.protobuf.Duration':
            case 'Duration':
                return [...m, utils_2.toAminoJSON.duration(args)];
            case 'google.protobuf.Timestamp':
            case 'Timestamp':
                return [...m, utils_2.toAminoJSON.timestamp(args)];
            default:
                switch (field.parsedType.type) {
                    case 'Enum':
                        return [...m, utils_2.toAminoJSON.enum(args)];
                    case 'Type':
                        return [...m, utils_2.toAminoJSON.type(args)];
                }
                return needsImplementation(fieldName, field);
        }
    }, []);
    return fields;
};
exports.toAminoJSONMethodFields = toAminoJSONMethodFields;
const toAminoJSONMethod = (context, name, proto) => {
    const fields = (0, exports.toAminoJSONMethodFields)(context, name, proto);
    let varName = 'message';
    if (!fields.length) {
        varName = '_';
    }
    const AminoTypeName = types_1.SymbolNames.Amino(name);
    const body = [];
    // 1. some messages we parse specially
    if (proto.type === 'Type') {
        switch (proto.name) {
            case 'Duration':
            case 'google.protobuf.Duration': {
                body.push(utils_2.toAminoMessages.duration(context, name, proto));
                break;
            }
            case 'Timestamp':
            case 'google.protobuf.Timestamp':
                body.push(utils_2.toAminoMessages.timestamp(context, name, proto));
                break;
            case 'google.protobuf.Any':
            case 'Any':
                [].push.apply(body, utils_2.toAminoMessages.anyType());
                break;
            default:
        }
    }
    if (!body.length) {
        // 2. default to field-level parsing
        [].push.apply(body, [
            t.variableDeclaration('const', [
                t.variableDeclarator((0, utils_1.identifier)('obj', t.tsTypeAnnotation(t.tsAnyKeyword())), t.objectExpression([]))
            ]),
            ...fields,
            // RETURN
            t.returnStatement(t.identifier('obj'))
        ]);
    }
    return (0, utils_1.objectMethod)('method', t.identifier('toAmino'), [
        (0, utils_1.identifier)(varName, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(name)))),
        ...(context.options.interfaces.enabled && context.options.interfaces.useUseInterfacesParams ? [
            t.assignmentPattern((0, utils_1.identifier)('useInterfaces', t.tsTypeAnnotation(t.tsBooleanKeyword())), t.identifier((context.pluginValue('interfaces.useByDefault') ?? true).toString()))
        ] : []),
    ], t.blockStatement(body), false, false, false, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(AminoTypeName))));
};
exports.toAminoJSONMethod = toAminoJSONMethod;
const toAminoMsgMethod = (context, name, proto) => {
    const varName = 'message';
    const ReturnType = types_1.SymbolNames.AminoMsg(name);
    const TypeName = types_1.SymbolNames.Msg(name);
    const aminoType = (0, amino_1.getAminoTypeName)(context, context.ref.proto, proto);
    if (!aminoType || aminoType.startsWith('/'))
        return;
    const body = [];
    // body
    body.push(t.returnStatement(t.objectExpression([
        t.objectProperty(t.identifier('type'), t.stringLiteral(aminoType)),
        t.objectProperty(t.identifier('value'), t.callExpression(t.memberExpression(t.identifier(TypeName), t.identifier('toAmino')), [
            t.identifier(varName),
            ...(context.options.interfaces.enabled && context.options.interfaces.useUseInterfacesParams ? [
                t.identifier('useInterfaces')
            ] : []),
        ]))
    ])));
    return (0, utils_1.objectMethod)('method', t.identifier('toAminoMsg'), [
        (0, utils_1.identifier)(varName, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(TypeName)))),
        ...(context.options.interfaces.enabled && context.options.interfaces.useUseInterfacesParams ? [
            t.assignmentPattern((0, utils_1.identifier)('useInterfaces', t.tsTypeAnnotation(t.tsBooleanKeyword())), t.identifier((context.pluginValue('interfaces.useByDefault') ?? true).toString()))
        ] : []),
    ], t.blockStatement(body), false, false, false, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(ReturnType))));
};
exports.toAminoMsgMethod = toAminoMsgMethod;
