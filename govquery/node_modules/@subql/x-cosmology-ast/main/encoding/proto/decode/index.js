"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeMethod = exports.decodeMethodFields = void 0;
const t = __importStar(require("@babel/types"));
const __1 = require("..");
const utils_1 = require("../../../utils");
const types_1 = require("../types");
const utils_2 = require("./utils");
const binary_coder_expression_1 = require("../../../utils/binary-coder-expression");
const needsImplementation = (name, field) => {
    throw new Error(`need to implement decode (${field.type} rules[${field.rule}] name[${name}])`);
};
const decodeMethodFields = (context, name, proto) => {
    const oneOfs = (0, __1.getOneOfs)(proto);
    return Object.keys(proto.fields ?? {}).map(fieldName => {
        const field = {
            name: fieldName,
            ...proto.fields[fieldName]
        };
        const isOneOf = oneOfs.includes(fieldName);
        const isOptional = (0, __1.getFieldOptionality)(context, field, isOneOf);
        const args = {
            typeName: name,
            context,
            field,
            isOptional
        };
        if (field.rule === 'repeated') {
            switch (field.type) {
                case 'string':
                    return utils_2.decode.array(args, utils_2.baseTypes.string(args));
                case 'bytes':
                    return utils_2.decode.array(args, utils_2.baseTypes.bytes(args));
                case 'double':
                    return utils_2.decode.tagDelimArray(args, utils_2.baseTypes.double(args));
                case 'bool':
                    return utils_2.decode.tagDelimArray(args, utils_2.baseTypes.bool(args));
                case 'float':
                    return utils_2.decode.tagDelimArray(args, utils_2.baseTypes.float(args));
                case 'int32':
                    return utils_2.decode.tagDelimArray(args, utils_2.baseTypes.int32(args));
                case 'sint32':
                    return utils_2.decode.tagDelimArray(args, utils_2.baseTypes.sint32(args));
                case 'uint32':
                    return utils_2.decode.tagDelimArray(args, utils_2.baseTypes.uint32(args));
                case 'fixed32':
                    return utils_2.decode.tagDelimArray(args, utils_2.baseTypes.fixed32(args));
                case 'sfixed32':
                    return utils_2.decode.tagDelimArray(args, utils_2.baseTypes.sfixed32(args));
                case 'int64':
                    return utils_2.decode.tagDelimArray(args, utils_2.baseTypes.int64(args));
                case 'sint64':
                    return utils_2.decode.tagDelimArray(args, utils_2.baseTypes.sint64(args));
                case 'uint64':
                    return utils_2.decode.tagDelimArray(args, utils_2.baseTypes.uint64(args));
                case 'fixed64':
                    return utils_2.decode.tagDelimArray(args, utils_2.baseTypes.fixed64(args));
                case 'sfixed64':
                    return utils_2.decode.tagDelimArray(args, utils_2.baseTypes.sfixed64(args));
                default:
                    switch (field.parsedType.type) {
                        case 'Enum':
                            return utils_2.decode.tagDelimArray(args, utils_2.baseTypes.enum(args));
                        case 'Type':
                            return utils_2.decode.typeArray(args);
                    }
                    return needsImplementation(fieldName, field);
            }
        }
        if (field.keyType) {
            // currently they all look the same for decode()
            return utils_2.decode.keyHash(args);
        }
        switch (field.type) {
            case 'string':
                return utils_2.decode.string(args);
            case 'int32':
                return utils_2.decode.int32(args);
            case 'sint32':
                return utils_2.decode.sint32(args);
            case 'uint32':
                return utils_2.decode.uint32(args);
            case 'fixed32':
                return utils_2.decode.fixed32(args);
            case 'sfixed32':
                return utils_2.decode.sfixed32(args);
            case 'int64':
                return utils_2.decode.int64(args);
            case 'sint64':
                return utils_2.decode.sint64(args);
            case 'uint64':
                return utils_2.decode.uint64(args);
            case 'fixed64':
                return utils_2.decode.fixed64(args);
            case 'sfixed64':
                return utils_2.decode.sfixed64(args);
            case 'double':
                return utils_2.decode.double(args);
            case 'float':
                return utils_2.decode.float(args);
            case 'bytes':
                return utils_2.decode.bytes(args);
            case 'bool':
                return utils_2.decode.bool(args);
            case 'google.protobuf.Duration':
            case 'Duration':
                return utils_2.decode.duration(args);
            case 'google.protobuf.Timestamp':
            case 'Timestamp':
                return utils_2.decode.timestamp(args);
            default:
                switch (field.parsedType.type) {
                    case 'Enum':
                        return utils_2.decode.enum(args);
                    case 'Type':
                        return utils_2.decode.type(args);
                }
                return needsImplementation(fieldName, field);
        }
    });
};
exports.decodeMethodFields = decodeMethodFields;
const decodeMethod = (context, name, proto) => {
    binary_coder_expression_1.BinaryCoder.addUtil(context);
    let returnType = name;
    // decode can be coupled to API requests
    if (context.store.responses[name]) {
        // returnType = name + 'SDKType';
        returnType = name;
    }
    return (0, utils_1.objectMethod)('method', t.identifier('decode'), [
        (0, utils_1.identifier)('input', t.tsTypeAnnotation(t.tsUnionType([
            binary_coder_expression_1.BinaryCoder.getReaderTypeRef(context),
            t.tsTypeReference(t.identifier('Uint8Array'))
        ])), false),
        (0, utils_1.identifier)('length', t.tsTypeAnnotation(t.tsNumberKeyword()), true),
        ...(context.options.interfaces.enabled && context.options.interfaces.useUseInterfacesParams ? [
            t.assignmentPattern((0, utils_1.identifier)('useInterfaces', t.tsTypeAnnotation(t.tsBooleanKeyword())), t.identifier((context.pluginValue('interfaces.useByDefault') ?? true).toString()))
        ] : []),
    ], t.blockStatement([
        /*
const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        */
        t.variableDeclaration('const', [
            t.variableDeclarator(t.identifier('reader'), t.conditionalExpression(t.binaryExpression('instanceof', t.identifier('input'), binary_coder_expression_1.BinaryCoder.getReaderMemberExp(context)), t.identifier('input'), t.newExpression(binary_coder_expression_1.BinaryCoder.getReaderMemberExp(context), [
                t.identifier('input')
            ])))
        ]),
        /*
let end = length === undefined ? reader.len : reader.pos + length;
        */
        t.variableDeclaration('let', [
            t.variableDeclarator(t.identifier('end'), t.conditionalExpression(t.binaryExpression('===', t.identifier('length'), t.identifier('undefined')), t.memberExpression(t.identifier('reader'), t.identifier('len')), t.binaryExpression('+', t.memberExpression(t.identifier('reader'), t.identifier('pos')), t.identifier('length'))))
        ]),
        /*

const message = createBaseMsgJoinPool();

        */
        t.variableDeclaration('const', [
            t.variableDeclarator(t.identifier('message'), t.callExpression(
            //
            t.identifier((0, types_1.getBaseCreateTypeFuncName)(name)), []))
        ]),
        ///////////
        ///////////
        ///////////
        t.whileStatement(t.binaryExpression('<', t.memberExpression(t.identifier('reader'), t.identifier('pos')), t.identifier('end')), t.blockStatement([
            /// DECODE BODY
            t.variableDeclaration('const', [
                t.variableDeclarator(t.identifier('tag'), t.callExpression(t.memberExpression(t.identifier('reader'), t.identifier('uint32')), []))
            ]),
            t.switchStatement(t.binaryExpression('>>>', t.identifier('tag'), t.numericLiteral(3)), [
                ...(0, exports.decodeMethodFields)(context, name, proto),
                /*
                default:
                        reader.skipType(tag & 7);
                        break;
                */
                t.switchCase(null, [
                    t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('reader'), t.identifier('skipType')), [
                        t.binaryExpression('&', t.identifier('tag'), t.numericLiteral(7))
                    ])),
                    t.breakStatement()
                ])
            ])
        ])),
        // RETURN STATEMENT
        t.returnStatement(t.identifier('message'))
    ]), false, false, false, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(returnType))));
};
exports.decodeMethod = decodeMethod;
