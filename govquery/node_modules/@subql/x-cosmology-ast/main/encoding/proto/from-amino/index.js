"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromAminoMsgMethod = exports.fromAminoJSONMethod = exports.fromAminoMethodFields = void 0;
const t = __importStar(require("@babel/types"));
const __1 = require("..");
const utils_1 = require("../../../utils");
const types_1 = require("../types");
const utils_2 = require("./utils");
const types_2 = require("../../types");
const needsImplementation = (name, field) => {
    throw new Error(`need to implement fromAmino (${field.type} rules[${field.rule}] name[${name}])`);
};
const fromAminoMethodFields = (context, name, proto) => {
    const oneOfs = (0, __1.getOneOfs)(proto);
    const fields = Object.keys(proto.fields ?? {}).map((fieldName) => {
        const field = {
            name: fieldName,
            ...proto.fields[fieldName],
        };
        const isOneOf = oneOfs.includes(fieldName);
        const isOptional = (0, __1.getFieldOptionality)(context, field, isOneOf);
        const args = {
            context,
            field,
            isOneOf,
            isOptional,
        };
        if (field.rule === "repeated") {
            switch (field.type) {
                case "string":
                    return utils_2.fromAmino.array(args, utils_2.arrayTypes.string());
                case "bytes":
                    return utils_2.fromAmino.array(args, utils_2.arrayTypes.bytes(args));
                case "bool":
                    return utils_2.fromAmino.array(args, utils_2.arrayTypes.bool());
                case "float":
                    return utils_2.fromAmino.array(args, utils_2.arrayTypes.float());
                case "double":
                    return utils_2.fromAmino.array(args, utils_2.arrayTypes.double());
                case "int32":
                    return utils_2.fromAmino.array(args, utils_2.arrayTypes.int32());
                case "sint32":
                    return utils_2.fromAmino.array(args, utils_2.arrayTypes.sint32());
                case "uint32":
                    return utils_2.fromAmino.array(args, utils_2.arrayTypes.uint32());
                case "fixed32":
                    return utils_2.fromAmino.array(args, utils_2.arrayTypes.fixed32());
                case "sfixed32":
                    return utils_2.fromAmino.array(args, utils_2.arrayTypes.sfixed32());
                case "int64":
                    return utils_2.fromAmino.array(args, utils_2.arrayTypes.int64(args));
                case "sint64":
                    return utils_2.fromAmino.array(args, utils_2.arrayTypes.sint64(args));
                case "uint64":
                    return utils_2.fromAmino.array(args, utils_2.arrayTypes.uint64(args));
                case "fixed64":
                    return utils_2.fromAmino.array(args, utils_2.arrayTypes.fixed64(args));
                case "sfixed64":
                    return utils_2.fromAmino.array(args, utils_2.arrayTypes.sfixed64(args));
                default:
                    switch (field.parsedType.type) {
                        case "Enum":
                            return utils_2.fromAmino.array(args, utils_2.arrayTypes.enum(args));
                        case "Type":
                            return utils_2.fromAmino.array(args, utils_2.arrayTypes.type(args));
                    }
                    return needsImplementation(fieldName, field);
            }
        }
        if (field.keyType) {
            switch (field.keyType) {
                case "string":
                case "int32":
                case "sint32":
                case "uint32":
                case "fixed32":
                case "sfixed32":
                case "int64":
                case "sint64":
                case "uint64":
                case "fixed64":
                case "sfixed64":
                    return utils_2.fromAmino.keyHash(args);
                default:
                    return needsImplementation(fieldName, field);
            }
        }
        // casting special types
        if (field.type === "google.protobuf.Any") {
            switch (field.options?.["(cosmos_proto.accepts_interface)"]) {
                case "cosmos.crypto.PubKey":
                    return utils_2.fromAmino.pubkey(args);
            }
        }
        if (field.type === "bytes") {
            // bytes [RawContractMessage]
            if (field.options?.["(gogoproto.casttype)"] === "RawContractMessage") {
                return utils_2.fromAmino.rawBytes(args);
            }
            // bytes [WASMByteCode]
            // TODO use a better option for this in proto source
            if (field.options?.["(gogoproto.customname)"] === "WASMByteCode") {
                return utils_2.fromAmino.wasmByteCode(args);
            }
        }
        // default types
        switch (field.type) {
            case "string":
                return utils_2.fromAmino.string(args);
            case "bytes":
                return utils_2.fromAmino.bytes(args);
            case "bool":
                return utils_2.fromAmino.bool(args);
            case "double":
                return utils_2.fromAmino.double(args);
            case "float":
                return utils_2.fromAmino.float(args);
            case "int32":
                return utils_2.fromAmino.int32(args);
            case "sint32":
                return utils_2.fromAmino.sint32(args);
            case "uint32":
                return utils_2.fromAmino.uint32(args);
            case "fixed32":
                return utils_2.fromAmino.fixed32(args);
            case "sfixed32":
                return utils_2.fromAmino.sfixed32(args);
            case "int64":
                return utils_2.fromAmino.int64(args);
            case "sint64":
                return utils_2.fromAmino.sint64(args);
            case "uint64":
                return utils_2.fromAmino.uint64(args);
            case "fixed64":
                return utils_2.fromAmino.fixed64(args);
            case "sfixed64":
                return utils_2.fromAmino.sfixed64(args);
            case "Duration":
            case "google.protobuf.Duration":
                return utils_2.fromAmino.duration(args);
            case "Timestamp":
            case "google.protobuf.Timestamp":
                return utils_2.fromAmino.timestamp(args);
            default:
                switch (field.parsedType.type) {
                    case "Enum":
                        return utils_2.fromAmino.enum(args);
                    case "Type":
                        return utils_2.fromAmino.type(args);
                }
                return needsImplementation(fieldName, field);
        }
    });
    return fields;
};
exports.fromAminoMethodFields = fromAminoMethodFields;
const fromAminoJSONMethod = (context, name, proto) => {
    const fields = (0, exports.fromAminoMethodFields)(context, name, proto);
    let varName = "object";
    if (!fields.length) {
        varName = "_";
    }
    const aminoTypeName = types_2.SymbolNames.Amino(name);
    const param = (0, utils_1.identifier)(varName, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(aminoTypeName))));
    let body = [];
    if (proto.type === "Type") {
        switch (proto.name) {
            case "Duration": {
                if (proto.package === "google.protobuf") {
                    [].push.apply(body, utils_2.fromAminoMessages.duration(context, name, proto));
                }
                break;
            }
            case "Height": {
                if (proto.package === "ibc.core.client.v1") {
                    [].push.apply(body, utils_2.fromAminoMessages.height(context, name, proto));
                }
                break;
            }
            case "Timestamp":
            case "google.protobuf.Timestamp":
                [].push.apply(body, utils_2.fromAminoMessages.timestamp(context, name, proto));
                break;
            case "google.protobuf.Any":
            case "Any":
                [].push.apply(body, utils_2.fromAminoMessages.anyType());
                break;
            default:
        }
    }
    if (!body.length) {
        // 2. default to field-level parsing
        body = [
            // init
            t.variableDeclaration("const", [
                t.variableDeclarator(t.identifier("message"), t.callExpression(t.identifier((0, types_1.getBaseCreateTypeFuncName)(name)), [])),
            ]),
            ...fields,
            // RETURN
            t.returnStatement(t.identifier("message")),
        ];
    }
    return (0, utils_1.objectMethod)("method", t.identifier("fromAmino"), [param], t.blockStatement(body), false, false, false, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(name))));
};
exports.fromAminoJSONMethod = fromAminoJSONMethod;
const fromAminoMsgMethod = (context, name, proto) => {
    const varName = "object";
    const TypeName = types_2.SymbolNames.Msg(name);
    const AminoMsgName = types_2.SymbolNames.AminoMsg(name);
    const ReturnType = types_2.SymbolNames.Msg(name);
    const body = [];
    body.push(t.returnStatement(t.callExpression(t.memberExpression(t.identifier(TypeName), t.identifier("fromAmino")), [t.memberExpression(t.identifier(varName), t.identifier("value"))])));
    return (0, utils_1.objectMethod)("method", t.identifier("fromAminoMsg"), [
        (0, utils_1.identifier)(varName, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(AminoMsgName))), false),
    ], t.blockStatement(body), false, false, false, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(ReturnType))));
};
exports.fromAminoMsgMethod = fromAminoMsgMethod;
