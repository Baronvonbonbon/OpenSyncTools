"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProtoEnumToJSON = exports.createProtoEnumFromJSON = exports.createProtoEnum = void 0;
const t = __importStar(require("@babel/types"));
const types_1 = require("./types");
const utils_1 = require("../../utils");
const getEnumValues = (proto) => {
    const enums = Object.keys(proto.values).map(key => {
        const e = {
            name: key,
            comment: null,
            value: null
        };
        e.value = proto.values[key];
        if (proto.comments[key]) {
            e.comment = proto.comments[key];
        }
        return e;
    });
    return enums;
};
const ensureOneSpace = (str) => {
    if (/^[\s\n\t]+/.test(str))
        return str;
    return ` ${str}`;
};
const processEnumComment = (e) => {
    const comment = e.comment;
    if (!/[\n]+/.test(comment)) {
        return `* ${e.name} - ${comment} `;
    }
    let lines = comment.split('\n');
    lines = ['*', ...lines, ' '];
    const comments = lines.map((line, i) => {
        if (i == 0)
            return line;
        if (i == 1)
            return ` * ${e.name} - ${(0, utils_1.cleanComment)(line)}`;
        if (i == (lines.length - 1))
            return (0, utils_1.cleanComment)(line);
        return ` *${ensureOneSpace((0, utils_1.cleanComment)(line))}`;
    });
    return comments.join('\n');
};
const createProtoEnum = (context, name, proto) => {
    const enums = getEnumValues(proto);
    const values = enums.map(e => {
        return (0, utils_1.tsEnumMember)(t.identifier(e.name), t.numericLiteral(e.value), e.comment ? [{
                type: 'CommentBlock',
                // @ts-ignore
                value: processEnumComment(e)
            }] : []);
    });
    const declaration = t.exportNamedDeclaration(t.tsEnumDeclaration(t.identifier(name), [
        ...values,
        // default
        (0, utils_1.tsEnumMember)(t.identifier('UNRECOGNIZED'), t.unaryExpression('-', t.numericLiteral(1)), null),
    ]));
    if (proto.comment) {
        declaration.leadingComments = [
            (0, utils_1.makeCommentBlock)(proto.comment)
        ];
    }
    return declaration;
};
exports.createProtoEnum = createProtoEnum;
const createProtoEnumFromJSON = (context, name, proto) => {
    const enums = getEnumValues(proto);
    const switches = enums.reduce((m, e) => {
        m.push(t.switchCase(t.numericLiteral(e.value), []));
        m.push(t.switchCase(t.stringLiteral(e.name), [
            t.returnStatement(t.memberExpression(t.identifier(name), t.identifier(e.name)))
        ]));
        return m;
    }, []);
    const unrecognizedEnums = [
        t.switchCase(t.stringLiteral('UNRECOGNIZED'), [])
    ];
    return t.exportNamedDeclaration((0, utils_1.functionDeclaration)(t.identifier((0, types_1.getEnumFromJsonName)(name)), [
        (0, utils_1.identifier)('object', t.tsTypeAnnotation(t.tsAnyKeyword()))
    ], t.blockStatement([
        t.switchStatement(t.identifier('object'), [
            ...switches,
            // default
            t.switchCase(t.unaryExpression('-', t.numericLiteral(1)), []),
            ...unrecognizedEnums,
            t.switchCase(null, [
                t.returnStatement(t.memberExpression(t.identifier(name), t.identifier('UNRECOGNIZED')))
            ])
        ])
    ]), false, false, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(name)))));
};
exports.createProtoEnumFromJSON = createProtoEnumFromJSON;
const createProtoEnumToJSON = (context, name, proto) => {
    const enums = getEnumValues(proto);
    const switches = enums.map(e => {
        return t.switchCase(t.memberExpression(t.identifier(name), t.identifier(e.name)), [
            t.returnStatement(t.stringLiteral(e.name))
        ]);
    });
    const unrecognizedEnums = [
        t.switchCase(t.memberExpression(t.identifier(name), t.identifier('UNRECOGNIZED')), [])
    ];
    return t.exportNamedDeclaration((0, utils_1.functionDeclaration)(t.identifier((0, types_1.getEnumToJsonName)(name)), [
        (0, utils_1.identifier)('object', t.tsTypeAnnotation(t.tsTypeReference(t.identifier(name))))
    ], t.blockStatement([
        t.switchStatement(t.identifier('object'), [
            ...switches,
            // unrecognized
            ...unrecognizedEnums,
            // default
            t.switchCase(null, [
                t.returnStatement(t.stringLiteral('UNRECOGNIZED'))
            ])
        ])
    ]), false, false, t.tsTypeAnnotation(t.tsStringKeyword())));
};
exports.createProtoEnumToJSON = createProtoEnumToJSON;
