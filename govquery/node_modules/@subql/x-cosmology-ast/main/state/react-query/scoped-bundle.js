"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createScopedRpcHookFactory = exports.rpcHookTmNestedImportObject = exports.rpcHookRecursiveObjectProps = exports.rpcHookNewTmRequire = exports.rpcHookClassArguments = exports.rpcHookFuncArguments = void 0;
const t = __importStar(require("@babel/types"));
const utils_1 = require("../../utils");
const x_cosmology_utils_1 = require("@subql/x-cosmology-utils");
const utils_2 = require("../../utils");
const rpcHookFuncArguments = () => {
    return [
        (0, utils_1.objectPattern)([t.objectProperty(t.identifier('rpc'), t.identifier('rpc'), false, true)], t.tsTypeAnnotation(t.tsTypeLiteral([
            t.tsPropertySignature(t.identifier('rpc'), t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Rpc'))))
        ])))
    ];
};
exports.rpcHookFuncArguments = rpcHookFuncArguments;
const rpcHookClassArguments = () => {
    return [
        t.objectExpression([
            t.objectProperty(t.identifier('rpc'), t.identifier('rpc'), false, true)
        ])
    ];
};
exports.rpcHookClassArguments = rpcHookClassArguments;
/**
 * Create an AST for a certain key and hook.
 * eg: __fixtures__/output1/hooks.ts
 * v1beta2: _AkashAuditV1beta2Queryrpc.createRpcQueryHooks(rpc)
 * @param {Object=} imports - imports array reference for generating imports.
 * @param {Object=} path - filename of a package.
 * @param {string} methodName - hook method name of packages
 * @returns {ParseResult} created AST
 */
const rpcHookNewTmRequire = (imports, path, methodName) => {
    imports.push({
        as: (0, x_cosmology_utils_1.variableSlug)(path),
        path
    });
    return t.callExpression(t.memberExpression(t.identifier((0, x_cosmology_utils_1.variableSlug)(path)), t.identifier(methodName)), [t.identifier('rpc')]);
};
exports.rpcHookNewTmRequire = rpcHookNewTmRequire;
const rpcHookRecursiveObjectProps = (names, leaf) => {
    const [name, ...rest] = names;
    let baseComponent;
    if (names.length === 1) {
        baseComponent = leaf ? leaf : t.identifier(name);
    }
    else {
        baseComponent = (0, exports.rpcHookRecursiveObjectProps)(rest, leaf);
    }
    return t.objectExpression([
        t.objectProperty(t.identifier(name), baseComponent)
    ]);
};
exports.rpcHookRecursiveObjectProps = rpcHookRecursiveObjectProps;
/**
 * Create an ASTs for hooks of packages recursively, and get imports of packages.
 * eg: __fixtures__/output1/hooks.ts
 * export const createRpcQueryHooks = ...
 * @param {Object=} imports - imports array reference for generating imports.
 * @param {Object=} obj - mapping of packages and rpc query filenames
 * @param {string} methodName - hook method name of packages
 * @returns {ParseResult} created AST
 */
const rpcHookTmNestedImportObject = (imports, obj, methodName) => {
    //if obj is a path, end recursion and get the mapping.
    if (typeof obj === 'string') {
        return (0, exports.rpcHookNewTmRequire)(imports, obj, methodName);
    }
    const keys = Object.keys(obj);
    // get hooks for keys of the obj.
    return t.objectExpression(keys.map((name) => {
        return t.objectProperty(t.identifier(name), (0, exports.rpcHookTmNestedImportObject)(imports, obj[name], methodName));
    }));
};
exports.rpcHookTmNestedImportObject = rpcHookTmNestedImportObject;
/**
 * Create an ASTs for createRpcQueryHooks and imports of related packages.
 * eg: __fixtures__/output1/hooks.ts
 * import * as _AkashAuditV1beta2Queryrpc from ...
 * export const createRpcQueryHooks = ...
 * @param {Object=} context - context of generating the file
 * @param {Object=} obj - mapping of packages and rpc query filenames
 * @param {string} identifier - name of function creating hooks. eg: createRpcQueryHooks
 * @returns {ParseResult} created AST
 */
const createScopedRpcHookFactory = (context, obj, identifier, instantHooksMapping) => {
    return (0, utils_2.buildExportCreators)(context, obj, identifier, ['ProtobufRpcClient'], undefined, instantHooksMapping);
};
exports.createScopedRpcHookFactory = createScopedRpcHookFactory;
