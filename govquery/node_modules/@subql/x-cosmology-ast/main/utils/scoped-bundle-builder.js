"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildExportCreators = exports.buildNestedCreator = exports.buildSingleCreator = exports.buildInstantHooks = void 0;
const t = __importStar(require("@babel/types"));
const _1 = require(".");
const x_cosmology_utils_1 = require("@subql/x-cosmology-utils");
const DEFAULT_RPC_PARAM_NAME = 'rpc';
const buildInstantHooks = (methodName, instantHooksMapping) => {
    return Object.keys(instantHooksMapping ?? []).map((hookName) => {
        const hookObj = instantHooksMapping[hookName];
        return (0, _1.objectProperty)(t.identifier(hookName), t.memberExpression(t.callExpression(t.memberExpression(t.identifier(hookObj.importedVarName), t.identifier(methodName)), [t.identifier(DEFAULT_RPC_PARAM_NAME)]), t.identifier(hookObj.useHookName)), false, false, undefined, (0, _1.makeCommentLineWithBlocks)(hookObj.comment));
    });
};
exports.buildInstantHooks = buildInstantHooks;
/**
 * Create an AST for a certain key and method.
 * eg: __fixtures__/output1/hooks.ts
 * v1beta2: _AkashAuditV1beta2Queryrpc.createRpcQueryHooks(rpc)
 * @param {Object=} imports - imports array reference for generating imports.
 * @param {Object=} path - filename of a package.
 * @param {string} methodName - hook method name of packages
 * @returns {ParseResult} created AST
 */
const buildSingleCreator = (imports, path, methodName) => {
    imports.push({
        as: (0, x_cosmology_utils_1.variableSlug)(path),
        path
    });
    return t.callExpression(t.memberExpression(t.identifier((0, x_cosmology_utils_1.variableSlug)(path)), t.identifier(methodName)), [t.identifier(DEFAULT_RPC_PARAM_NAME)]);
};
exports.buildSingleCreator = buildSingleCreator;
/**
 * Create an ASTs for method creators of packages recursively, and get imports of packages.
 * eg: __fixtures__/output1/hooks.ts
 * export const createRpcQueryHooks = ...
 * @param {Object=} imports - imports array reference for generating imports.
 * @param {Object=} obj - mapping of packages and rpc query filenames
 * @param {string} methodName - hook method name of packages
 * @returns {ParseResult} created AST
 */
const buildNestedCreator = (imports, obj, methodName) => {
    //if obj is a path, end recursion and get the mapping.
    if (typeof obj === 'string') {
        return (0, exports.buildSingleCreator)(imports, obj, methodName);
    }
    const keys = Object.keys(obj);
    // get hooks for keys of the obj.
    return t.objectExpression(keys.map((name) => {
        return t.objectProperty(t.identifier(name), (0, exports.buildNestedCreator)(imports, obj[name], methodName));
    }));
};
exports.buildNestedCreator = buildNestedCreator;
/**
 * Create an ASTs for export creators.
 * Generating files like:
 * __fixtures__/output1/hooks.ts
 * @param {Object=} context - context of generating the file
 * @param {Object=} obj - mapping of packages and rpc query filenames
 * @param {string} identifier - name of function creating hooks. eg: createRpcQueryHooks
 * @param {string[]} utils - name of imported utils.
 * @param {string} methodName - name of a certain method that creates a store or hook. eg: createRpcQueryHooks
 * @returns {ParseResult} created AST
 */
const buildExportCreators = (context, obj, identifier, utils, methodName = 'createRpcQueryHooks', instantHooksMapping) => {
    // add imports
    utils.forEach((util) => {
        context.addUtil(util);
    });
    const hookImports = [];
    const returnedHooksExpression = (0, exports.buildNestedCreator)(hookImports, obj, methodName);
    const instantHooks = (0, exports.buildInstantHooks)(methodName, instantHooksMapping);
    returnedHooksExpression.properties.push(...instantHooks);
    const ast = t.exportNamedDeclaration(t.variableDeclaration('const', [
        t.variableDeclarator(
        // eg: createRPCQueryHooks
        t.identifier(identifier), t.arrowFunctionExpression([
            (0, _1.objectPattern)([
                t.objectProperty(t.identifier(DEFAULT_RPC_PARAM_NAME), t.identifier(DEFAULT_RPC_PARAM_NAME), false, true)
            ], t.tsTypeAnnotation(t.tsTypeLiteral([
                t.tsPropertySignature(t.identifier(DEFAULT_RPC_PARAM_NAME), t.tsTypeAnnotation(t.tsUnionType([
                    t.tsTypeReference(t.identifier('ProtobufRpcClient')),
                    t.tsUndefinedKeyword()
                ])))
            ])))
        ], t.blockStatement([
            t.returnStatement(returnedHooksExpression)
        ]), false))
    ]));
    // generate imports for packages.
    const imports = hookImports.map((hookport) => {
        return {
            type: 'ImportDeclaration',
            importKind: 'value',
            specifiers: [
                {
                    type: 'ImportNamespaceSpecifier',
                    local: {
                        type: 'Identifier',
                        name: hookport.as
                    }
                }
            ],
            source: {
                type: 'StringLiteral',
                value: hookport.path
            }
        };
    });
    return [...imports, ast];
};
exports.buildExportCreators = buildExportCreators;
