"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAminoFieldName = exports.getSdkFieldName = exports.getAcceptedInterfacesTypes = exports.promiseTypeAnnotation = exports.memberExpressionOrIdentifierAminoCaseField = exports.memberExpressionOrIdentifierAminoCasing = exports.memberExpressionOrIdentifier = exports.importStmt = exports.shorthandProperty = exports.bindMethod = exports.recursiveNamespace = exports.getProtoFieldTypeName = exports.renderNameSafely = exports.makeCommentBlock = exports.cleanComment = exports.BILLION = void 0;
const t = __importStar(require("@babel/types"));
const BILLION = t.numericLiteral(1_000_000_000);
exports.BILLION = BILLION;
BILLION.extra = { raw: "1_000_000_000", rawValue: 1000000000 };
const cleanComment = (str) => {
    return str.replace(/\*\//g, "*\\/");
};
exports.cleanComment = cleanComment;
const ensureOneSpace = (str) => {
    if (/^[\s\n\t]+/.test(str))
        return str;
    return ` ${str}`;
};
const makeCommentBlock = (comment) => {
    if (!/[\n]+/.test(comment)) {
        return {
            type: "CommentBlock",
            value: `* ${(0, exports.cleanComment)(comment)} `,
            start: null,
            end: null,
            loc: null,
        };
    }
    let lines = comment.split("\n");
    lines = ["*", ...lines, " "];
    const comments = lines.map((line, i) => {
        if (i == 0)
            return line;
        if (i == 1)
            return ` *${ensureOneSpace((0, exports.cleanComment)(line))}`;
        if (i == lines.length - 1)
            return (0, exports.cleanComment)(line);
        return ` *${ensureOneSpace((0, exports.cleanComment)(line))}`;
    });
    return {
        type: "CommentBlock",
        value: comments.join("\n"),
        start: null,
        end: null,
        loc: null,
    };
};
exports.makeCommentBlock = makeCommentBlock;
const renderNameSafely = (name) => {
    return name
        .split("_")
        .map((str) => {
        const parts = str.split(".");
        str = parts[parts.length - 1];
        return str;
    })
        .join("_");
};
exports.renderNameSafely = renderNameSafely;
const getProtoFieldTypeName = (context, field) => {
    let name = context.getTypeName(field);
    return (0, exports.renderNameSafely)(name);
};
exports.getProtoFieldTypeName = getProtoFieldTypeName;
const recursiveNamespace = (names, moduleBlockBody) => {
    if (!names || !names.length)
        return moduleBlockBody;
    const name = names.pop();
    const body = [
        t.exportNamedDeclaration(t.tsModuleDeclaration(t.identifier(name), t.tsModuleBlock((0, exports.recursiveNamespace)(names, moduleBlockBody)))),
    ];
    return body;
};
exports.recursiveNamespace = recursiveNamespace;
const bindMethod = (name) => {
    return t.expressionStatement(t.assignmentExpression("=", t.memberExpression(t.thisExpression(), t.identifier(name)), t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier(name)), t.identifier("bind")), [t.thisExpression()])));
};
exports.bindMethod = bindMethod;
const shorthandProperty = (prop) => {
    return t.objectProperty(t.identifier(prop), t.identifier(prop), false, true);
};
exports.shorthandProperty = shorthandProperty;
const importStmt = (names, path) => {
    return t.importDeclaration(names.map((name) => t.importSpecifier(t.identifier(name), t.identifier(name))), t.stringLiteral(path));
};
exports.importStmt = importStmt;
const memberExpressionOrIdentifier = (names) => {
    if (names.length === 1) {
        return t.identifier(names[0]);
    }
    if (names.length === 2) {
        const [b, a] = names;
        return t.memberExpression(t.identifier(a), t.identifier(b));
    }
    const [name, ...rest] = names;
    return t.memberExpression((0, exports.memberExpressionOrIdentifier)(rest), t.identifier(name));
};
exports.memberExpressionOrIdentifier = memberExpressionOrIdentifier;
const memberExpressionOrIdentifierAminoCasing = (names, aminoCasingFn) => {
    if (names.length === 1) {
        return t.identifier(aminoCasingFn(names[0]));
    }
    if (names.length === 2) {
        const [b, a] = names;
        return t.memberExpression(t.identifier(aminoCasingFn(a)), t.identifier(aminoCasingFn(b)));
    }
    const [name, ...rest] = names;
    return t.memberExpression((0, exports.memberExpressionOrIdentifierAminoCasing)(rest, aminoCasingFn), t.identifier(aminoCasingFn(name)));
};
exports.memberExpressionOrIdentifierAminoCasing = memberExpressionOrIdentifierAminoCasing;
const memberExpressionOrIdentifierAminoCaseField = (fields, aminoCaseFunc) => {
    if (fields.length === 1) {
        return t.identifier(aminoCaseFunc(fields[0]));
    }
    if (fields.length === 2) {
        const [b, a] = fields;
        return t.memberExpression(t.identifier(aminoCaseFunc(a)), t.identifier(aminoCaseFunc(b)));
    }
    const [field, ...rest] = fields;
    return t.memberExpression((0, exports.memberExpressionOrIdentifierAminoCaseField)(rest, aminoCaseFunc), t.identifier(aminoCaseFunc(field)));
};
exports.memberExpressionOrIdentifierAminoCaseField = memberExpressionOrIdentifierAminoCaseField;
const promiseTypeAnnotation = (name) => {
    return t.tsTypeAnnotation(t.tsTypeReference(t.identifier("Promise"), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(name))])));
};
exports.promiseTypeAnnotation = promiseTypeAnnotation;
const getAcceptedInterfacesTypes = (context, lookupInterface) => {
    return lookupInterface ? context.store._symbols.filter((s) => s.implementsType === lookupInterface && s.ref === context.ref.filename) : [];
};
exports.getAcceptedInterfacesTypes = getAcceptedInterfacesTypes;
const getSdkFieldName = (fieldName, field) => {
    return field.options?.["(telescope:orig)"] ?? fieldName;
};
exports.getSdkFieldName = getSdkFieldName;
const getAminoFieldName = (fieldName, field, interfaceName, context) => {
    const orig = field.options?.["(telescope:orig)"] ?? fieldName;
    if ((interfaceName === "Any" &&
        context.ref.proto.package === "google.protobuf" &&
        (orig === "type_url" || orig === "typeUrl"))) {
        // type_url => type for amino
        return "type";
    }
    return orig;
};
exports.getAminoFieldName = getAminoFieldName;
