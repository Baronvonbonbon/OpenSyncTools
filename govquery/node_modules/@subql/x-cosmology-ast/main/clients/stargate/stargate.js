"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGetTxRpc = exports.createStargateClientOptions = exports.createStargateClientProtoRegistry = exports.createStargateClientAminoRegistry = exports.createStargateClient = void 0;
const t = __importStar(require("@babel/types"));
const utils_1 = require("../../utils");
const createStargateClient = ({ name, options, context, }) => {
    const includeDefaults = context.pluginValue("stargateClients.includeCosmosDefaultTypes");
    let optsFuncArgs = [];
    if (includeDefaults) {
        context.addUtil("defaultRegistryTypes");
        optsFuncArgs = [
            t.objectExpression([
                t.objectProperty(t.identifier("defaultTypes"), t.identifier("defaultTypes"), false, true),
            ]),
        ];
    }
    context.addUtil("GeneratedType");
    context.addUtil("OfflineSigner");
    context.addUtil("Registry");
    context.addUtil("AminoTypes");
    context.addUtil("SigningStargateClient");
    context.addUtil("HttpEndpoint");
    const prop = t.tsPropertySignature(t.identifier("defaultTypes"), t.tsTypeAnnotation(t.tsTypeReference(t.identifier("ReadonlyArray"), t.tsTypeParameterInstantiation([
        t.tsTupleType([
            t.tsStringKeyword(),
            t.tsTypeReference(t.identifier("GeneratedType")),
        ]),
    ]))));
    prop.optional = true;
    return t.exportNamedDeclaration(t.variableDeclaration("const", [
        t.variableDeclarator(t.identifier(name), t.arrowFunctionExpression([
            (0, utils_1.objectPattern)([
                t.objectProperty(t.identifier("rpcEndpoint"), t.identifier("rpcEndpoint"), false, true),
                t.objectProperty(t.identifier("signer"), t.identifier("signer"), false, true),
                includeDefaults &&
                    t.objectProperty(t.identifier("defaultTypes"), t.assignmentPattern(t.identifier("defaultTypes"), t.identifier("defaultRegistryTypes")), false, true),
            ].filter(Boolean), t.tsTypeAnnotation(t.tsTypeLiteral([
                t.tsPropertySignature(t.identifier("rpcEndpoint"), t.tsTypeAnnotation(t.tsUnionType([
                    t.tsStringKeyword(),
                    t.tsTypeReference(t.identifier("HttpEndpoint")),
                ]))),
                t.tsPropertySignature(t.identifier("signer"), t.tsTypeAnnotation(t.tsTypeReference(t.identifier("OfflineSigner")))),
                includeDefaults && prop,
            ].filter(Boolean)))),
        ], t.blockStatement([
            // props
            t.variableDeclaration("const", [
                t.variableDeclarator(t.objectPattern([
                    t.objectProperty(t.identifier("registry"), t.identifier("registry"), false, true),
                    t.objectProperty(t.identifier("aminoTypes"), t.identifier("aminoTypes"), false, true),
                ]), t.callExpression(t.identifier(options), optsFuncArgs)),
            ]),
            // client
            t.variableDeclaration("const", [
                t.variableDeclarator(t.identifier("client"), t.awaitExpression(t.callExpression(t.memberExpression(t.identifier("SigningStargateClient"), t.identifier("connectWithSigner")), [
                    t.identifier("rpcEndpoint"),
                    t.identifier("signer"),
                    t.objectExpression([
                        t.objectProperty(t.identifier("registry"), t.tsAsExpression(t.identifier("registry"), t.tsAnyKeyword())),
                        t.objectProperty(t.identifier("aminoTypes"), t.identifier("aminoTypes"), false, true),
                    ]),
                ]))),
            ]),
            // return
            t.returnStatement(t.identifier("client")),
        ]), true)),
    ]));
};
exports.createStargateClient = createStargateClient;
const createStargateClientAminoRegistry = ({ aminos, aminoConverters, context, }) => {
    return t.exportNamedDeclaration(t.variableDeclaration("const", [
        t.variableDeclarator(t.identifier(aminoConverters), t.objectExpression([
            ...aminos.map((pkg) => t.spreadElement((0, utils_1.memberExpressionOrIdentifier)(`${pkg}.AminoConverter`.split(".").reverse()))),
        ])),
    ]));
};
exports.createStargateClientAminoRegistry = createStargateClientAminoRegistry;
const createStargateClientProtoRegistry = ({ registries, protoTypeRegistry, context, }) => {
    context.addUtil("GeneratedType");
    return t.exportNamedDeclaration(t.variableDeclaration("const", [
        t.variableDeclarator((0, utils_1.identifier)(protoTypeRegistry, t.tsTypeAnnotation(t.tsTypeReference(t.identifier("ReadonlyArray"), t.tsTypeParameterInstantiation([
            t.tsTupleType([
                t.tsStringKeyword(),
                t.tsTypeReference(t.identifier("GeneratedType")),
            ]),
        ])))), t.arrayExpression([
            ...registries.map((pkg) => t.spreadElement((0, utils_1.memberExpressionOrIdentifier)(`${pkg}.registry`.split(".").reverse()))),
        ])),
    ]));
};
exports.createStargateClientProtoRegistry = createStargateClientProtoRegistry;
const createStargateClientOptions = ({ name, aminoConverters, protoTypeRegistry, context, }) => {
    const includeDefaults = context.pluginValue("stargateClients.includeCosmosDefaultTypes");
    if (includeDefaults) {
        context.addUtil("defaultRegistryTypes");
    }
    context.addUtil("GeneratedType");
    context.addUtil("Registry");
    context.addUtil("AminoTypes");
    context.addUtil("SigningStargateClient");
    const prop = t.tsPropertySignature(t.identifier("defaultTypes"), t.tsTypeAnnotation(t.tsTypeReference(t.identifier("ReadonlyArray"), t.tsTypeParameterInstantiation([
        t.tsTupleType([
            t.tsStringKeyword(),
            t.tsTypeReference(t.identifier("GeneratedType")),
        ]),
    ]))));
    prop.optional = true;
    let funcArgs = [];
    if (includeDefaults) {
        const args = [
            t.objectProperty(t.identifier("defaultTypes"), t.assignmentPattern(t.identifier("defaultTypes"), t.identifier("defaultRegistryTypes")), false, true),
        ];
        //
        const funcTypes = t.tsTypeAnnotation(t.tsTypeLiteral([prop].filter(Boolean)));
        funcArgs = [
            t.assignmentPattern((0, utils_1.objectPattern)(args, funcTypes), t.objectExpression([])),
        ];
    }
    return t.exportNamedDeclaration(t.variableDeclaration("const", [
        t.variableDeclarator(t.identifier(name), (0, utils_1.arrowFunctionExpression)(funcArgs, t.blockStatement([
            t.variableDeclaration("const", [
                t.variableDeclarator(t.identifier("registry"), t.newExpression(t.identifier("Registry"), [
                    t.arrayExpression([
                        includeDefaults &&
                            t.spreadElement(t.identifier("defaultTypes")),
                        t.spreadElement(t.identifier(protoTypeRegistry)),
                    ].filter(Boolean)),
                ])),
            ]),
            // amino
            t.variableDeclaration("const", [
                t.variableDeclarator(t.identifier("aminoTypes"), t.newExpression(t.identifier("AminoTypes"), [
                    t.objectExpression([
                        t.spreadElement(t.identifier(aminoConverters)),
                    ]),
                ])),
            ]),
            // NEW CODE
            // return
            t.returnStatement(t.objectExpression([
                t.objectProperty(t.identifier("registry"), t.identifier("registry"), false, true),
                t.objectProperty(t.identifier("aminoTypes"), t.identifier("aminoTypes"), false, true),
            ])),
        ]), t.tsTypeAnnotation(t.tsTypeLiteral([
            t.tsPropertySignature(t.identifier("registry"), t.tsTypeAnnotation(t.tsTypeReference(t.identifier("Registry")))),
            t.tsPropertySignature(t.identifier("aminoTypes"), t.tsTypeAnnotation(t.tsTypeReference(t.identifier("AminoTypes")))),
        ])), false)),
    ]));
};
exports.createStargateClientOptions = createStargateClientOptions;
const createGetTxRpc = (ctx, name, clientName) => {
    ctx.addUtil("createRpcClient");
    ctx.addUtil("DeliverTxResponse");
    ctx.addUtil("EncodeObject");
    ctx.addUtil("StdFee");
    ctx.addUtil("TxRpc");
    ctx.addUtil("SigningClientParams");
    const paramExpr = t.objectPattern([
        t.objectProperty(t.identifier("rpcEndpoint"), t.identifier("rpcEndpoint"), false, true),
        t.objectProperty(t.identifier("signer"), t.identifier("signer"), false, true),
    ]);
    paramExpr.typeAnnotation = t.tsTypeAnnotation(t.tsTypeReference(t.identifier("SigningClientParams")));
    const methodArgs = [
        (0, utils_1.identifier)("signerAddress", t.tsTypeAnnotation(t.tsStringKeyword())),
        (0, utils_1.identifier)("messages", t.tsTypeAnnotation(t.tsArrayType(t.tsTypeReference(t.identifier("EncodeObject"))))),
        (0, utils_1.identifier)("fee", t.tsTypeAnnotation(t.tsUnionType([
            t.tsNumberKeyword(),
            t.tsTypeReference(t.identifier("StdFee")),
            t.tsLiteralType(t.stringLiteral("auto")),
        ]))),
        (0, utils_1.identifier)("memo", t.tsTypeAnnotation(t.tsStringKeyword()), true),
    ];
    return t.exportNamedDeclaration(t.variableDeclaration("const", [
        t.variableDeclarator(t.identifier(name), t.arrowFunctionExpression([paramExpr], t.blockStatement([
            t.variableDeclaration("let", [
                t.variableDeclarator(t.identifier("txRpc"), t.tSAsExpression(t.awaitExpression(t.callExpression(t.identifier("createRpcClient"), [
                    t.identifier("rpcEndpoint"),
                ])), t.tSTypeReference(t.identifier("TxRpc"), null))),
            ]),
            t.variableDeclaration("const", [
                t.variableDeclarator(t.identifier("signingClient"), t.awaitExpression(t.callExpression(t.identifier(clientName), [
                    t.objectExpression([
                        t.objectProperty(t.identifier("rpcEndpoint"), t.identifier("rpcEndpoint"), false, true),
                        t.objectProperty(t.identifier("signer"), t.identifier("signer"), false, true),
                    ]),
                ]))),
            ]),
            t.expressionStatement(t.assignmentExpression("=", t.memberExpression(t.identifier("txRpc"), t.identifier("signAndBroadcast")), t.arrowFunctionExpression(methodArgs, t.blockStatement([
                t.returnStatement(t.tSAsExpression(t.callExpression(t.memberExpression(t.identifier("signingClient"), t.identifier("signAndBroadcast")), [
                    t.identifier("signerAddress"),
                    t.identifier("messages"),
                    t.identifier("fee"),
                    t.identifier("memo"),
                ]), t.tSTypeReference(t.identifier("Promise"), t.tSTypeParameterInstantiation([
                    t.tSTypeReference(t.identifier("DeliverTxResponse")),
                ])))),
            ], [])))),
            t.returnStatement(t.identifier("txRpc")),
        ], []), true)),
    ]), []);
};
exports.createGetTxRpc = createGetTxRpc;
