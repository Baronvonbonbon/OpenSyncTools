"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRpcMsgExtension = exports.createRpcClientImpl = exports.createRpcQueryExtension = void 0;
const t = __importStar(require("@babel/types"));
const utils_1 = require("../../../utils");
const x_cosmology_utils_1 = require("@subql/x-cosmology-utils");
const tendermint_1 = require("../class/tendermint");
const rpcExtensionMethod = (context, name, svc) => {
    const requestType = svc.requestType;
    const responseType = svc.responseType;
    const fieldNames = Object.keys(svc.fields ?? {});
    const hasParams = fieldNames.length > 0;
    let optional = false;
    // // if no params, then let's default to empty object for cleaner API
    if (!hasParams) {
        optional = true;
    }
    else if (hasParams &&
        fieldNames.length === 1 &&
        fieldNames.includes("pagination")) {
        // if only argument "required" is pagination
        // also default to empty
        optional = true;
    }
    const methodArgs = (0, utils_1.identifier)("request", t.tsTypeAnnotation(t.tsTypeReference(t.identifier(requestType))), optional);
    return (0, utils_1.objectMethod)("method", t.identifier(name), [
        methodArgs,
        ...(context.options.interfaces.enabled &&
            context.options.interfaces.useUseInterfacesParams
            ? [
                t.assignmentPattern((0, utils_1.identifier)("useInterfaces", t.tsTypeAnnotation(t.tsBooleanKeyword())), t.identifier((context.pluginValue("interfaces.useByDefaultRpc") ?? true).toString())),
            ]
            : []),
    ], t.blockStatement([
        t.returnStatement(t.callExpression(t.memberExpression(t.identifier("queryService"), t.identifier(name)), [
            t.identifier("request"),
            ...(context.options.interfaces.enabled &&
                context.options.interfaces.useUseInterfacesParams
                ? [t.identifier("useInterfaces")]
                : []),
        ])),
    ]), false, false, false, t.tsTypeAnnotation(t.tsTypeReference(t.identifier("Promise"), t.tsTypeParameterInstantiation([
        t.tsTypeReference(
        // t.identifier(responseType + 'SDKType')
        t.identifier(responseType)),
    ]))));
};
const createRpcQueryExtension = (context, service) => {
    context.addUtil("QueryClient");
    context.addUtil("createProtobufRpcClient");
    const camelRpcMethods = context.pluginValue("rpcClients.camelCase");
    // const name = service.name + 'ClientImpl';
    // const implementsName = service.name;
    // const methodNames = Object.keys(service.methods ?? {})
    //     .map(key => {
    //         return camelRpcMethods ? camel(key) : key
    //     });
    const methods = Object.keys(service.methods ?? {}).map((key) => {
        const method = service.methods[key];
        const name = camelRpcMethods ? (0, x_cosmology_utils_1.camel)(key) : key;
        return rpcExtensionMethod(context, name, method);
    });
    return t.exportNamedDeclaration(t.variableDeclaration("const", [
        t.variableDeclarator(t.identifier("createRpcQueryExtension"), t.arrowFunctionExpression([
            (0, utils_1.identifier)("base", t.tsTypeAnnotation(t.tsTypeReference(t.identifier("QueryClient")))),
        ], t.blockStatement([
            t.variableDeclaration("const", [
                t.variableDeclarator(t.identifier("rpc"), t.callExpression(t.identifier("createProtobufRpcClient"), [
                    t.identifier("base"),
                ])),
            ]),
            //////
            t.variableDeclaration("const", [
                t.variableDeclarator(t.identifier("queryService"), t.newExpression(t.identifier((0, tendermint_1.getRpcClassName)(service)), [
                    t.identifier("rpc"),
                ])),
            ]),
            t.returnStatement(t.objectExpression([...methods])),
        ]))),
    ]));
};
exports.createRpcQueryExtension = createRpcQueryExtension;
const createRpcClientImpl = (context, service, functionName = "createClientImpl") => {
    const useTelescopeGeneratedType = context.pluginValue("prototypes.typingsFormat.useTelescopeGeneratedType");
    if (useTelescopeGeneratedType) {
        context.addUtil("TxRpc");
    }
    else {
        context.addUtil("Rpc");
    }
    const className = (0, tendermint_1.getRpcClassName)(service);
    return t.exportNamedDeclaration(t.variableDeclaration("const", [
        t.variableDeclarator(t.identifier(functionName), t.arrowFunctionExpression([
            (0, utils_1.identifier)("rpc", t.tsTypeAnnotation(t.tsTypeReference(t.identifier(useTelescopeGeneratedType ? "TxRpc" : "Rpc")))),
        ], t.blockStatement([
            t.returnStatement(t.newExpression(t.identifier(className), [t.identifier("rpc")])),
        ]))),
    ]));
};
exports.createRpcClientImpl = createRpcClientImpl;
const createRpcMsgExtension = (context, txRpcName) => {
    context.addUtil("HttpEndpoint");
    context.addUtil("OfflineSigner");
    let functionParams;
    let functionStatements;
    let awaitClientCreation;
    functionParams = [
        (0, utils_1.objectPattern)([
            t.objectProperty(t.identifier("rpcEndpoint"), t.identifier("rpcEndpoint"), false, true),
            t.objectProperty(t.identifier("signer"), t.identifier("signer"), false, true),
        ], t.tsTypeAnnotation(t.tsTypeLiteral([
            t.tsPropertySignature(t.identifier("rpcEndpoint"), t.tsTypeAnnotation(t.tsUnionType([
                t.tsStringKeyword(),
                t.tsTypeReference(t.identifier("HttpEndpoint")),
            ]))),
            t.tsPropertySignature(t.identifier("signer"), t.tsTypeAnnotation(t.tsTypeReference(t.identifier("OfflineSigner")))),
        ]))),
    ];
    awaitClientCreation = t.callExpression(t.identifier(txRpcName), [
        t.objectExpression([
            t.objectProperty(t.identifier("rpcEndpoint"), t.identifier("rpcEndpoint"), false, true),
            t.objectProperty(t.identifier("signer"), t.identifier("signer"), false, true),
        ]),
    ]);
    functionStatements = [
        t.variableDeclaration("const", [
            t.variableDeclarator(t.identifier("rpc"), t.awaitExpression(awaitClientCreation)),
        ]),
        t.returnStatement(t.awaitExpression(t.callExpression(t.identifier("createRPCMsgClient"), [
            t.objectExpression([
                t.objectProperty(t.identifier("rpc"), t.identifier("rpc"), false, true),
            ]),
        ]))),
    ];
    return t.exportNamedDeclaration(t.variableDeclaration("const", [
        t.variableDeclarator(t.identifier("createRPCMsgExtensions"), t.arrowFunctionExpression(functionParams, t.blockStatement(functionStatements), true)),
    ]));
};
exports.createRpcMsgExtension = createRpcMsgExtension;
