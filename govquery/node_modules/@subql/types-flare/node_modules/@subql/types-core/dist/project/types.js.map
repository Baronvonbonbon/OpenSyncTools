{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/project/types.ts"],"names":[],"mappings":";AAAA,8DAA8D;AAC9D,mCAAmC","sourcesContent":["// Copyright 2020-2024 SubQuery Pte Ltd authors & contributors\n// SPDX-License-Identifier: GPL-3.0\n\nimport {BaseDataSource, BaseTemplateDataSource, ParentProject, RunnerSpecs} from './versioned';\n\n/**\n * Represents a common subquery project configuration.\n * @template N - The type of the network configuration (default: CommonSubqueryNetworkConfig).\n * @template DS - The type of the base data source (default: BaseDataSource).\n * @template T - The type of templates (default: unknown).\n */\nexport interface CommonSubqueryProject<\n  N extends IProjectNetworkConfig = IProjectNetworkConfig,\n  DS extends BaseDataSource = BaseDataSource,\n  T extends BaseTemplateDataSource<DS> = BaseTemplateDataSource<DS>\n> {\n  /**\n   * The repository of your SubQuery project.\n   * @type {string}\n   */\n  repository?: string;\n  /**\n   * The version string of your SubQuery project.\n   * @type {string}\n   * @default \"1.0.0\"\n   */\n  version?: string;\n  /**\n   * The name of your SubQuery project.\n   * @type {string}\n   */\n  name?: string;\n  /**\n   * The specVersion of the SubQuery project manifest file, the latest and suggested is 1.0.0\n   * @type {string}\n   * @default \"1.0.0\"\n   */\n  specVersion: string;\n  /**\n   * A description of your SubQuery project.\n   * @type {string}\n   */\n  description?: string;\n  /**\n   * The location of your GraphQL schema file.\n   * @type {FileReference}\n   */\n  schema: FileReference;\n  /**\n   * The runner specifications for the common SubQuery project.\n   * @readonly\n   * @type {RunnerSpecs}\n   */\n  readonly runner?: RunnerSpecs;\n  /**\n   * The parent manifest of current project.\n   * @readonly\n   * @type {ParentProject}\n   */\n  readonly parent?: ParentProject;\n  /**\n   * The network configuration for the SubQuery project.\n   *\n   * This defines what network you are wanting to index as well as the details on how to conect to it.\n   * @readonly\n   * @type {N}\n   */\n  readonly network: N;\n  /**\n   * An array of data sources associated with the SubQuery project.\n   *\n   * Defines the data that will be filtered and extracted and the location of the mapping function handler for the data transformation to be applied.\n   * @readonly\n   * @type {DS[]}\n   */\n  readonly dataSources: DS[];\n  /**\n   * An array of project templates associated with the project.\n   *\n   * These are the same as datasources but instead of having a startBlock they have a unique name.\n   * These are used to dynamically create data sources, this is useful when you don't know the start block.\n   * e.g When a factory creates a new instance of a contract you can initialize a datasource from a template in your mapping function.\n   * @readonly\n   * @type {T[]}\n   */\n  readonly templates?: T[];\n}\n\n/**\n * Represents the common network configuration for a subquery project.\n * @interface\n * @extends {ProjectNetworkConfig}\n */\nexport interface IProjectNetworkConfig extends ProjectNetworkConfig {\n  /**\n   * The unique identity of the chain.\n   *\n   * This differs for different blockchain ecosystems, please refer to our documentation\n   * @type {string}\n   * @example\n   * chainId: '1' // Ethereum\n   * @example\n   * chainId: '0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3' // Polkadot\n   * @example\n   * chainId: 'juno-1' // Cosmos Juno\n   * */\n  chainId: string;\n}\n\nexport type DsProcessor<DS, P extends Record<string, any> = Record<string, any>, API = any> = {\n  kind: string;\n  validate: (ds: DS, assets: Record<string, string>) => void;\n  dsFilterProcessor: (ds: DS, api: API) => boolean;\n  handlerProcessors: P;\n};\n\nexport interface ProjectRootAndManifest {\n  root: string;\n  manifests: string[];\n}\n\nexport interface IProjectManifest<D> {\n  specVersion: string;\n  description?: string;\n  repository?: string;\n  dataSources: D[];\n  toDeployment(): string;\n  validate(): void;\n}\n\n/**\n * Represents the network configuration for a project.\n * @interface\n */\nexport interface ProjectNetworkConfig {\n  /**\n   * The endpoint(s) for the network connection, which can be a single string or an array of strings.\n   *\n   * Endpoints ideally should non-pruned archive nodes (so you have access for the entire chain state)\n   * We recommend providing more than one endpoint for improved reliability, performance, and uptime.\n   * Public nodes may be rate limited, which can affect indexing speed\n   * When developing your project we suggest adding a private API key\n   *\n   * @type {string | string[]}\n   */\n  endpoint: string | string[];\n\n  /**\n   * The SubQuery network dictionary endpoint (optional).\n   * This significantly speeds up indexing of your project.\n   *\n   * @type {string}\n   */\n  dictionary?: string | string[];\n\n  /**\n   * An array of block numbers or block ranges to bypass (optional).\n   * @type {(number | string)[]}\n   * @example\n   * [1, 2, 3, '5-10']\n   */\n  bypassBlocks?: (number | `${number}-${number}`)[];\n}\n\n/**\n * Represents a reference to a file.\n * @interface\n */\nexport interface FileReference {\n  /**\n   * The path or name of the referenced file from the root of this project.\n   * @type {string}\n   */\n  file: string;\n}\nexport type Processor<O = any> = FileReference & {options?: O};\n\nexport interface DictionaryQueryCondition {\n  field: string;\n  value: string | string[] | boolean;\n  matcher?: string; // defaults to \"equalTo\", use \"contains\" for JSON\n}\n\nexport interface DictionaryQueryEntry {\n  entity: string;\n  conditions: DictionaryQueryCondition[];\n}\n"]}