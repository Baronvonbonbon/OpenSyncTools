"use strict";
// Copyright 2020-2025 SubQuery Pte Ltd authors & contributors
// SPDX-License-Identifier: GPL-3.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadFromJsonOrYaml = loadFromJsonOrYaml;
exports.getManifestPath = getManifestPath;
exports.getSchemaPath = getSchemaPath;
exports.getProjectNetwork = getProjectNetwork;
exports.getFileContent = getFileContent;
exports.validateCommonProjectManifest = validateCommonProjectManifest;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const class_transformer_1 = require("class-transformer");
const class_validator_1 = require("class-validator");
const js_yaml_1 = __importDefault(require("js-yaml"));
const semver_1 = require("semver");
const __1 = require("../");
const constants_1 = require("../constants");
const utils_1 = require("./utils");
function loadFromJsonOrYaml(file) {
    const { ext } = path_1.default.parse(file);
    if (!(0, utils_1.extensionIsYamlOrJSON)(ext)) {
        throw new Error(`Extension ${ext} not supported`);
    }
    const rawContent = fs_1.default.readFileSync(file, 'utf-8');
    return js_yaml_1.default.load(rawContent);
}
function getManifestPath(manifestDir, fileName) {
    let manifestPath = manifestDir;
    if (fs_1.default.existsSync(manifestDir) && fs_1.default.lstatSync(manifestDir).isDirectory()) {
        const tsFilePath = path_1.default.join(manifestDir, fileName ?? utils_1.DEFAULT_TS_MANIFEST);
        const yamlFilePath = path_1.default.join(manifestDir, fileName ?? utils_1.DEFAULT_MANIFEST);
        const jsonFilePath = path_1.default.join(manifestDir, fileName ?? 'project.json');
        if (fs_1.default.existsSync(tsFilePath)) {
            manifestPath = tsFilePath;
        }
        else if (fs_1.default.existsSync(yamlFilePath)) {
            manifestPath = yamlFilePath;
        }
        else if (fs_1.default.existsSync(jsonFilePath)) {
            manifestPath = jsonFilePath;
        }
        else {
            throw new Error(`Could not find project manifest under dir ${manifestDir}`);
        }
    }
    return manifestPath;
}
function getSchemaPath(manifestDir, fileName) {
    const rawProject = loadFromJsonOrYaml(getManifestPath(manifestDir, fileName));
    if (rawProject.specVersion === '0.0.1') {
        return path_1.default.join(manifestDir, rawProject.schema);
    }
    const project = rawProject;
    if (!project.schema) {
        throw new Error(`Can't get schema in yaml file`);
    }
    if (!project.schema.file) {
        throw new Error(`schemaPath expect to be schema.file`);
    }
    return path_1.default.join(manifestDir, project.schema.file);
}
// Only work for manifest specVersion >= 1.0.0
function getProjectNetwork(rawManifest) {
    if ((0, semver_1.gte)(rawManifest.specVersion, '1.0.0')) {
        const network = constants_1.runnerMapping[rawManifest.runner.node.name];
        if (network === undefined) {
            throw new Error(`Can not identify project network with runner node ${rawManifest.runner.node.name}`);
        }
        return network;
    }
    else {
        throw new Error('Can not identify project network under spec version 1.0.0');
    }
}
/**
 * @param path path to the file
 * @param identifier name to be used for logging purpose
 * @returns file content
 */
function getFileContent(path, identifier) {
    if (!fs_1.default.existsSync(path)) {
        const err_msg = `${identifier} file ${path} is does not exist`;
        throw new Error(err_msg);
    }
    try {
        return fs_1.default.readFileSync(path).toString();
    }
    catch (error) {
        const err_msg = `Failed to load ${identifier} file, ${error}`;
        throw new Error(err_msg);
    }
}
//  Validate generic/common section for project manifest
function validateCommonProjectManifest(raw) {
    const projectManifest = (0, class_transformer_1.plainToClass)(__1.CommonProjectManifestV1_0_0Impl, raw);
    const errors = (0, class_validator_1.validateSync)(projectManifest, { whitelist: true });
    if (errors?.length) {
        // TODO: print error details
        const errorMsgs = errors.map((e) => e.toString()).join('\n');
        throw new Error(`project validation failed.\n${errorMsgs}`);
    }
}
//# sourceMappingURL=load.js.map