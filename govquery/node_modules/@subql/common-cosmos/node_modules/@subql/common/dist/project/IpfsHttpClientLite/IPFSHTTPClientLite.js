"use strict";
// Copyright 2020-2025 SubQuery Pte Ltd authors & contributors
// SPDX-License-Identifier: GPL-3.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IPFSHTTPClientLite = void 0;
const axios_1 = __importDefault(require("axios"));
const form_data_1 = __importDefault(require("form-data"));
const utils_1 = require("./utils");
class IPFSHTTPClientLite {
    option;
    constructor(option) {
        this.option = option;
        if (option.url === undefined) {
            throw new Error('url is required');
        }
        this.option = option;
    }
    get url() {
        return this.option.url.toString();
    }
    /**
     * Returns content of the file addressed by a valid IPFS Path or CID
     */
    cat(ipfsCID) {
        return (0, utils_1.streamCat)(this.option.url, ipfsCID);
    }
    /**
     * Import a file or data into IPFS
     */
    async add(content, options) {
        const results = await this.addAll([content], options);
        return results[0];
    }
    /**
     * Pin a content with a given CID to a remote pinning service.
     */
    async pinRemoteAdd(cid, options) {
        const url = new URL(`${this.url}/pin/remote/add`);
        url.searchParams.append('arg', cid);
        url.searchParams.append('service', options.service);
        try {
            const response = await axios_1.default.post(url.toString(), {}, {
                headers: {
                    ...this.option.headers,
                },
            });
            return response.data;
        }
        catch (e) {
            throw new Error(`Failed to pin CID ${cid} to remote service`, { cause: e });
        }
    }
    /**
     * Import multiple files and data into IPFS
     */
    async addAll(source, options) {
        const formData = this.makeFormData(source);
        const url = new URL(`${this.url}/add`);
        if (options) {
            url.searchParams.append('pin', options.pin?.toString() ?? 'true');
            url.searchParams.append('cid-version', options.cidVersion?.toString() ?? '0');
            url.searchParams.append('wrap-with-directory', options.wrapWithDirectory?.toString() ?? 'false');
        }
        try {
            const response = await axios_1.default.post(url.toString(), formData, {
                headers: {
                    ...this.option.headers,
                    ...formData.getHeaders(),
                },
                maxBodyLength: Infinity,
                maxContentLength: Infinity,
            });
            const mapResponse = (raw) => ({
                path: raw.Name,
                cid: raw.Hash,
                size: parseInt(raw.Size, 10),
            });
            // If only one file is uploaded then the response is an object.
            if (typeof response.data === 'object') {
                return [mapResponse(response.data)];
            }
            const jsonLines = response.data.split('\n').filter((l) => l !== '');
            return jsonLines.map((line) => JSON.parse(line)).map(mapResponse);
        }
        catch (error) {
            throw new Error(`Failed to upload files to IPFS`, { cause: error });
        }
    }
    makeFormData(contents) {
        const formData = new form_data_1.default();
        for (const content of contents) {
            if (content instanceof Uint8Array) {
                formData.append('data', Buffer.from(content));
            }
            else if (typeof content === 'string') {
                formData.append('data', content);
            }
            else {
                formData.append('data', content.content, { filename: content.path });
            }
        }
        return formData;
    }
}
exports.IPFSHTTPClientLite = IPFSHTTPClientLite;
//# sourceMappingURL=IPFSHTTPClientLite.js.map