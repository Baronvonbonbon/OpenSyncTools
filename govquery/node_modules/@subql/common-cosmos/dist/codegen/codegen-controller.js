"use strict";
// // Copyright 2020-2025 SubQuery Pte Ltd authors & contributors
// SPDX-License-Identifier: GPL-3.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processProtoFilePath = processProtoFilePath;
exports.isProtoPath = isProtoPath;
exports.prepareCosmwasmJobs = prepareCosmwasmJobs;
exports.prepareSortedAssets = prepareSortedAssets;
exports.generateCosmwasm = generateCosmwasm;
exports.prepareProtobufRenderProps = prepareProtobufRenderProps;
exports.tempProtoDir = tempProtoDir;
exports.generateProto = generateProto;
exports.projectCodegen = projectCodegen;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const ts_codegen_1 = __importDefault(require("@cosmwasm/ts-codegen"));
const common_1 = require("@subql/common");
const x_cosmology_telescope_1 = __importDefault(require("@subql/x-cosmology-telescope"));
const fs_extra_1 = require("fs-extra");
const lodash_1 = require("lodash");
const project_1 = require("../project");
const constants_1 = require("./constants");
const util_1 = require("./util");
const TYPE_ROOT_DIR = 'src/types';
// Proto to ts
const PROTO_INTERFACES_ROOT_DIR = 'src/types/proto-interfaces';
const PROTO_INTERFACE_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../../templates/proto-interface.ts.ejs');
// CosmWasm to ts
const COSMWASM_INTERFACES_ROOT_DIR = 'src/types/cosmwasm-interfaces';
const COSMWASM_INTERFACE_WRAPPER_PATH = '/src/types/cosmwasm-interface-wrappers';
const COSMWASM_INTERFACE_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../../templates/cosmwasm-interfaces.ts.ejs');
function processProtoFilePath(path) {
    // removes `./proto` and `.proto` suffix, converts all `.` to `/`
    // should be able to accept more paths, not just from `proto directory`
    return `./proto-interfaces/${path.replace(/^\.\/proto\/|\.proto$/g, '').replace(/\./g, '/')}`;
}
function pathToNamespace(path) {
    return path
        .replace(/^\.\/proto\/|\.proto$/g, '')
        .split(/(?<=\\\\)\/|(?<!\\)\//)
        .join('.');
}
function pathToName(path) {
    return pathToNamespace(path)
        .split('.')
        .map((p) => (0, lodash_1.upperFirst)(p))
        .join('');
}
function isProtoPath(filePath, projectPath) {
    // check if the protobuf files are under ./proto directory
    return !!path_1.default.join(projectPath, filePath).startsWith(path_1.default.join(projectPath, './proto/'));
}
function prepareCosmwasmJobs(sortedAssets, loadReadAbi, upperFirst) {
    return Object.keys(sortedAssets).map((key) => {
        const value = sortedAssets[key];
        const readContract = loadReadAbi(value);
        const msgObject = {
            MsgInstantiateContract: upperFirst(readContract.instantiate?.title),
            MsgMigrateContract: upperFirst(readContract.migrate?.title),
            MsgExecuteContract: upperFirst(readContract.execute?.title),
        };
        const cleanObject = {};
        for (const key in msgObject) {
            if (msgObject[key]) {
                cleanObject[key] = msgObject[key];
            }
        }
        return {
            contract: upperFirst(key),
            messages: cleanObject,
        };
    });
}
function prepareSortedAssets(datasources, projectPath) {
    const sortedAssets = {};
    datasources
        .filter((d) => !!d?.assets && (0, project_1.isRuntimeCosmosDs)(d))
        .forEach((d) => {
        if (!d.assets)
            return;
        Object.entries(d.assets).map(([name, value]) => {
            const filePath = path_1.default.join(projectPath, value.file);
            if (!fs_1.default.existsSync(filePath)) {
                throw new Error(`Error: Asset ${name}, file ${value.file} does not exist`);
            }
            // using name provided in assets
            sortedAssets[name] = filePath;
        });
    });
    return sortedAssets;
}
async function generateCosmwasm(datasources, projectPath, prepareDirPath, upperFirst, renderTemplate) {
    const sortedAssets = prepareSortedAssets(datasources, projectPath);
    if (Object.keys(sortedAssets).length === 0) {
        return prepareDirPath(path_1.default.join(projectPath, COSMWASM_INTERFACES_ROOT_DIR), false);
    }
    await Promise.all([
        prepareDirPath(path_1.default.join(projectPath, COSMWASM_INTERFACES_ROOT_DIR), true),
        prepareDirPath(path_1.default.join(projectPath, COSMWASM_INTERFACE_WRAPPER_PATH), true),
    ]);
    try {
        await (0, ts_codegen_1.default)((0, constants_1.COSMWASM_OPTS)(path_1.default.join(projectPath, COSMWASM_INTERFACES_ROOT_DIR), Object.entries(sortedAssets).map(([name, dir]) => ({ name, dir: path_1.default.dirname(dir) }))));
        const renderJobs = prepareCosmwasmJobs(sortedAssets, util_1.loadCosmwasmAbis, upperFirst);
        await Promise.all(renderJobs.map((job) => {
            console.log('Cosmwasm types generated');
            return renderTemplate(COSMWASM_INTERFACE_TEMPLATE_PATH, path_1.default.join(projectPath, COSMWASM_INTERFACE_WRAPPER_PATH, `${job.contract}MsgWrapper.ts`), {
                props: { abi: job },
                helper: { upperFirst },
            });
        }));
    }
    catch (e) {
        console.error(`! Unable to generate from provided cosmwasm interface. ${e.message}\n` +
            'Please check the path of your abi path in the project.yaml');
    }
}
function prepareProtobufRenderProps(chaintypes, projectPath) {
    if (!chaintypes) {
        return [];
    }
    return chaintypes
        .filter((v) => v !== undefined)
        .flatMap((chaintype) => {
        return Object.entries(chaintype)
            .map(([key, value]) => {
            const filePath = path_1.default.join(projectPath, value.file);
            if (!fs_1.default.existsSync(filePath)) {
                throw new Error(`Error: chainType ${key}, file ${value.file} does not exist`);
            }
            if (!isProtoPath(value.file, projectPath)) {
                console.error(`Codegen will not apply for this file: ${value.file} Please ensure it is under the ./proto directory if you want to run codegen on it`);
            }
            // We only need to generate for RPC messages that are always prefixed with Msg
            const messages = value.messages.filter((m) => m.indexOf('Msg') === 0);
            if (!messages.length)
                return;
            return {
                messageNames: messages,
                namespace: pathToNamespace(value.file),
                name: pathToName(value.file),
                path: processProtoFilePath(value.file),
            };
        })
            .filter((v) => v !== undefined);
    });
}
/**
 * Makes a temporaray directory and populates it with some core protobufs used by all projects, then copies over the projects protobufs
 * */
async function tempProtoDir(projectPath) {
    const tmpDir = await (0, common_1.makeTempDir)();
    const userProto = path_1.default.join(projectPath, './proto');
    const commonProtoPaths = [
        require('@protobufs/amino'),
        require('@protobufs/confio'),
        require('@protobufs/cosmos'),
        require('@protobufs/cosmos_proto'),
        require('@protobufs/cosmwasm'),
        require('@protobufs/gogoproto'),
        require('@protobufs/google'),
        require('@protobufs/ibc'),
        require('@protobufs/tendermint'),
    ];
    commonProtoPaths.forEach((p) => {
        // ensure output format is a dir
        (0, fs_extra_1.copySync)(p, (0, util_1.tmpProtoDir)(tmpDir, p));
    });
    (0, fs_extra_1.copySync)(userProto, tmpDir, { overwrite: true });
    return tmpDir;
}
async function generateProto(chaintypes, projectPath, prepareDirPath, renderTemplate, upperFirst) {
    let tmpPath = '';
    try {
        tmpPath = await tempProtoDir(projectPath);
        const protobufRenderProps = prepareProtobufRenderProps(chaintypes, projectPath);
        const outputPath = path_1.default.join(projectPath, PROTO_INTERFACES_ROOT_DIR);
        await prepareDirPath(path_1.default.join(projectPath, PROTO_INTERFACES_ROOT_DIR), true);
        await (0, x_cosmology_telescope_1.default)({
            protoDirs: [tmpPath],
            outPath: outputPath,
            options: constants_1.TELESCOPE_OPTS,
        });
        console.log('* Protobuf types generated !');
        await renderTemplate(PROTO_INTERFACE_TEMPLATE_PATH, path_1.default.join(projectPath, TYPE_ROOT_DIR, 'CosmosMessageTypes.ts'), {
            props: { proto: protobufRenderProps },
            helper: { upperFirst },
        });
        console.log('* Cosmos message wrappers generated !');
    }
    catch (e) {
        const errorMessage = e.message.startsWith('Dependency')
            ? `Please add the missing protobuf file to ./proto directory`
            : '';
        console.log('ERRROR', e);
        throw new Error(`Failed to generate from protobufs. ${e.message}, ${errorMessage}`);
    }
    finally {
        if (tmpPath !== '') {
            fs_1.default.rmSync(tmpPath, { recursive: true, force: true });
        }
    }
}
/**
 * Generates typescript interfaces from proto files and cosmwasm abis
 * @param manifest
 * @param projectPath
 * @param prepareDirPath
 * @param renderTemplate
 * @param upperFirst
 * @param datasources
 */
async function projectCodegen(manifest, projectPath, prepareDirPath, renderTemplate, upperFirst, datasources) {
    const chainTypes = getChaintypes(manifest);
    if (chainTypes.length) {
        await generateProto(chainTypes, projectPath, prepareDirPath, renderTemplate, upperFirst);
    }
    await generateCosmwasm(datasources, projectPath, prepareDirPath, upperFirst, renderTemplate);
}
function getChaintypes(manifest) {
    return manifest
        .filter((m) => (0, util_1.validateCosmosManifest)(m))
        .map((m) => m.network.chaintypes)
        .filter((value) => value !== undefined)
        .filter((value) => Object.keys(value).length !== 0);
}
//# sourceMappingURL=codegen-controller.js.map