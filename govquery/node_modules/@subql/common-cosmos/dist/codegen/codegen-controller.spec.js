"use strict";
// // Copyright 2020-2025 SubQuery Pte Ltd authors & contributors
// SPDX-License-Identifier: GPL-3.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const ejs_1 = __importDefault(require("ejs"));
const lodash_1 = require("lodash");
const rimraf_1 = __importDefault(require("rimraf"));
const codegen_controller_1 = require("./codegen-controller");
const util_2 = require("./util");
const PROJECT_PATH = path_1.default.join(__dirname, '../../test/protoTest1');
const describeIf = (condition, ...args) => 
// eslint-disable-next-line jest/valid-describe-callback, jest/valid-title, jest/no-disabled-tests
condition ? describe(...args) : describe.skip(...args);
describe('Codegen cosmos', () => {
    describe('Protobuf to ts', () => {
        it('process protobuf file paths', () => {
            const p = './proto/cosmos/osmosis/poolmanager/v1beta1/swap_route.proto';
            expect((0, codegen_controller_1.processProtoFilePath)(p)).toBe('./proto-interfaces/cosmos/osmosis/poolmanager/v1beta1/swap_route');
        });
        it('should output correct protobuf render props', () => {
            const mockChainTypes = [
                {
                    'osmosis.gamm.v1beta1': {
                        file: './proto/osmosis/gamm/v1beta1/tx.proto',
                        messages: ['MsgSwapExactAmountIn'],
                    },
                },
                {
                    'osmosis.poolmanager.v1beta1': {
                        file: './proto/osmosis/poolmanager/v1beta1/swap_route.proto',
                        messages: ['MsgSwapAmountInRoute'],
                    },
                },
            ];
            expect((0, codegen_controller_1.prepareProtobufRenderProps)(mockChainTypes, PROJECT_PATH)).toStrictEqual([
                {
                    messageNames: ['MsgSwapExactAmountIn'],
                    namespace: 'osmosis.gamm.v1beta1.tx',
                    name: 'OsmosisGammV1beta1Tx',
                    path: './proto-interfaces/osmosis/gamm/v1beta1/tx',
                },
                {
                    messageNames: ['MsgSwapAmountInRoute'],
                    namespace: 'osmosis.poolmanager.v1beta1.swap_route',
                    name: 'OsmosisPoolmanagerV1beta1Swap_route',
                    path: './proto-interfaces/osmosis/poolmanager/v1beta1/swap_route',
                },
            ]);
        });
        it('prepareProtobufRenderProps should handle undefined and array undefined', () => {
            const mixedMockChainTypes = [
                {
                    'osmosis.poolmanager.v1beta1': {
                        file: './proto/osmosis/poolmanager/v1beta1/swap_route.proto',
                        messages: ['MsgSwapAmountInRoute'],
                    },
                },
                undefined,
            ];
            expect((0, codegen_controller_1.prepareProtobufRenderProps)(mixedMockChainTypes, PROJECT_PATH)).toStrictEqual([
                {
                    messageNames: ['MsgSwapAmountInRoute'],
                    name: 'OsmosisPoolmanagerV1beta1Swap_route',
                    namespace: 'osmosis.poolmanager.v1beta1.swap_route',
                    path: './proto-interfaces/osmosis/poolmanager/v1beta1/swap_route',
                },
            ]);
            expect((0, codegen_controller_1.prepareProtobufRenderProps)(undefined, PROJECT_PATH)).toStrictEqual([]);
            expect((0, codegen_controller_1.prepareProtobufRenderProps)([undefined], PROJECT_PATH)).toStrictEqual([]);
        });
        it('Should throw if path to protobuf does not exist', () => {
            const mockChainTypes = [
                {
                    'osmosis.gamm.v1beta1': {
                        file: './protato/osmosis/gamm/v1beta1/tx.proto',
                        messages: ['MsgSwapExactAmountIn'],
                    },
                },
            ];
            expect(() => (0, codegen_controller_1.prepareProtobufRenderProps)(mockChainTypes, PROJECT_PATH)).toThrow('Error: chainType osmosis.gamm.v1beta1, file ./protato/osmosis/gamm/v1beta1/tx.proto does not exist');
        });
        it('ensure correct regex for protoPath', () => {
            let p = './proto/cosmos/osmosis/gamm/v1beta1/tx.proto';
            expect((0, codegen_controller_1.isProtoPath)(p, PROJECT_PATH)).toBe(true);
            p = 'proto/cosmos/osmosis/gamm/v1beta1/tx.proto';
            expect((0, codegen_controller_1.isProtoPath)(p, PROJECT_PATH)).toBe(true);
            p = '../proto/cosmos/osmosis/gamm/v1beta1/tx.proto';
            expect((0, codegen_controller_1.isProtoPath)(p, PROJECT_PATH)).toBe(false);
            p = './protos/cosmos/osmosis/gamm/v1beta1/tx.proto';
            expect((0, codegen_controller_1.isProtoPath)(p, PROJECT_PATH)).toBe(false);
        });
        it('User provided common protos should only overwrite the provided .proto file', async () => {
            const tp = await (0, codegen_controller_1.tempProtoDir)(PROJECT_PATH);
            const v = await fs_1.default.promises.readFile(path_1.default.join(tp, './cosmos/base/v1beta1/coin.proto'));
            expect(v.toString()).toBe('fake proto');
            await (0, util_1.promisify)(rimraf_1.default)(tp);
        });
        it('renders correct codegen from ejs', async () => {
            const job = {
                props: {
                    proto: [
                        {
                            messageNames: ['MsgSwapExactAmountIn'],
                            namespace: 'osmosis.gamm.v1beta1.tx',
                            name: 'OsmosisGammV1beta1Tx',
                            path: './proto-interfaces/osmosis/gamm/v1beta1/tx',
                        },
                        {
                            messageNames: ['SwapAmountInRoute'],
                            namespace: 'osmosis.poolmanager.v1beta1.swap_route',
                            name: 'OsmosisPoolmanagerV1beta1Swap_route',
                            path: './proto-interfaces/osmosis/poolmanager/v1beta1/swap_route',
                        },
                    ],
                },
                helper: { upperFirst: lodash_1.upperFirst },
            };
            const output = await ejs_1.default.renderFile(path_1.default.resolve(__dirname, '../../templates/proto-interface.ts.ejs'), job);
            // await fs.promises.writeFile(path.join(PROJECT_PATH, 'test.ts'), data);
            const expectCodegen = `// SPDX-License-Identifier: Apache-2.0

// Auto-generated , DO NOT EDIT
import {CosmosMessage} from "@subql/types-cosmos";

import * as OsmosisGammV1beta1Tx from "./proto-interfaces/osmosis/gamm/v1beta1/tx";

import * as OsmosisPoolmanagerV1beta1Swap_route from "./proto-interfaces/osmosis/poolmanager/v1beta1/swap_route";


export namespace osmosis.gamm.v1beta1.tx {

  export type MsgSwapExactAmountInMessage = CosmosMessage<OsmosisGammV1beta1Tx.MsgSwapExactAmountIn>;
}

export namespace osmosis.poolmanager.v1beta1.swap_route {

  export type SwapAmountInRouteMessage = CosmosMessage<OsmosisPoolmanagerV1beta1Swap_route.SwapAmountInRoute>;
}

`;
            expect(output).toEqual(expectCodegen);
            // const output = await fs.promises.readFile(path.join(PROJECT_PATH, 'test.ts'));
            // expect(output.toString()).toMatch(expectCodegen);
            // await promisify(rimraf)(path.join(PROJECT_PATH, 'test.ts'));
        });
    });
    describe('CosmWasm codegen', () => {
        it('ensure prepareSortedAssets', () => {
            const cosmosDs = {
                kind: 'cosmos/Runtime',
                startBlock: 6000000,
                options: { abi: 'cw20' },
                assets: { cw20: { file: './cosmwasm-contract/cw20/schema/cw20.json' } },
                mapping: {
                    file: './dist/index.js',
                    handlers: [
                        {
                            handler: 'handleMessage',
                            kind: 'cosmos/MessageHandler',
                            filter: { type: '/cosmwasm.wasm.v1.MsgExecuteContract' },
                        },
                    ],
                },
            };
            const expectedOutput = { cw20: path_1.default.join(PROJECT_PATH, 'cosmwasm-contract/cw20/schema/cw20.json') };
            expect((0, codegen_controller_1.prepareSortedAssets)([cosmosDs], PROJECT_PATH)).toStrictEqual(expectedOutput);
        });
        it('sortedAssets should only be of cosmosDs', () => {
            const notCosmosDs = {
                kind: 'ethereum/Runtime',
                startBlock: 6000000,
                options: { abi: 'cw20' },
                assets: { cw20: { file: './cosmwasm-contract/cw20/schema/cw20.json' } },
                mapping: {
                    file: './dist/index.js',
                    handlers: [
                        {
                            handler: 'handleMessage',
                            kind: 'cosmos/MessageHandler',
                            filter: { type: '/cosmwasm.wasm.v1.MsgExecuteContract' },
                        },
                    ],
                },
            };
            expect((0, codegen_controller_1.prepareSortedAssets)([notCosmosDs], PROJECT_PATH)).toStrictEqual({});
        });
        it('Correct output on processCosmwasm render jobs', () => {
            const mockSortedAssets = {
                cw20: path_1.default.join(PROJECT_PATH, 'cosmwasm-contract/cw20/schema/cw20.json'),
            };
            expect((0, codegen_controller_1.prepareCosmwasmJobs)(mockSortedAssets, util_2.loadCosmwasmAbis, lodash_1.upperFirst)).toStrictEqual([
                {
                    contract: 'Cw20',
                    messages: {
                        MsgInstantiateContract: 'InstantiateMsg',
                        MsgExecuteContract: 'ExecuteMsg',
                    },
                },
            ]);
        });
        it('renders correct codegen from ejs', async () => {
            const mockJob = {
                contract: 'Cw20',
                messages: {
                    MsgInstantiateContract: 'InstantiateMsg',
                    MsgExecuteContract: 'ExecuteMsg',
                },
            };
            const data = await ejs_1.default.renderFile(path_1.default.resolve(__dirname, '../../templates/cosmwasm-interfaces.ts.ejs'), {
                props: { abi: mockJob },
                helper: { upperFirst: lodash_1.upperFirst },
            });
            await fs_1.default.promises.writeFile(path_1.default.join(PROJECT_PATH, 'test.ts'), data);
            const expectCodegen = '' +
                '// SPDX-License-Identifier: Apache-2.0\n' +
                '\n' +
                '// Auto-generated, DO NOT EDIT\n' +
                'import { CosmosMessage, MsgInstantiateContract,MsgExecuteContract } from "@subql/types-cosmos";\n' +
                '\n' +
                'import { InstantiateMsg, ExecuteMsg } from "../cosmwasm-interfaces/Cw20.types";\n' +
                '\n' +
                '\n' +
                'export type Cw20InstantiateMsg = CosmosMessage<MsgInstantiateContract<InstantiateMsg>>;\n' +
                '\n' +
                'export type Cw20ExecuteMsg = CosmosMessage<MsgExecuteContract<ExecuteMsg>>;\n';
            const output = await fs_1.default.promises.readFile(path_1.default.join(PROJECT_PATH, 'test.ts'));
            expect(output.toString()).toMatch(expectCodegen);
            await (0, util_1.promisify)(rimraf_1.default)(path_1.default.join(PROJECT_PATH, 'test.ts'));
        });
    });
    it('ensure correct protoDir on macos', () => {
        const protoPath = '/Users/ben/subql-workspace/node/subql/node_modules/@protobufs/amino';
        const tmpDir = '/var/folders/ks/720tmlnn3fj6m4sg91c7spjm0000gn/T/wS0Gob';
        const macosPath = path_1.default.join(tmpDir, `${protoPath.replace(path_1.default.dirname(protoPath), '')}`);
        expect((0, util_2.tmpProtoDir)(tmpDir, protoPath)).toEqual(macosPath);
    });
    describeIf(os_1.default.platform() === 'win32', 'ensure correct protoDir on windowsOs', () => {
        it('correct pathing on windows', () => {
            const winProtoPath = 'C:\\Users\\zzz\\subql\\subql\\node_modules@protobufs\\amino';
            const winTmpDir = 'C:\\Users\\zzz\\AppData\\Local\\Temp\\GZTuPZ';
            expect((0, util_2.tmpProtoDir)(winTmpDir, winProtoPath)).toEqual('C:\\Users\\zzz\\AppData\\Local\\Temp\\GZTuPZ\\amino');
        });
    });
});
//# sourceMappingURL=codegen-controller.spec.js.map