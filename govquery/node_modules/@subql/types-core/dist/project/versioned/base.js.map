{"version":3,"file":"base.js","sourceRoot":"","sources":["../../../src/project/versioned/base.ts"],"names":[],"mappings":";AAAA,8DAA8D;AAC9D,mCAAmC","sourcesContent":["// Copyright 2020-2025 SubQuery Pte Ltd authors & contributors\n// SPDX-License-Identifier: GPL-3.0\n\nimport {ParentProject} from '../../project';\nimport {FileReference, Processor} from '../types';\n\nexport interface BaseDataSource<H extends BaseHandler = BaseHandler, M extends BaseMapping<H> = BaseMapping<H>> {\n  /**\n   * The kind of the datasource.\n   * @type {string}\n   */\n  kind: string;\n  /**\n   * The starting block number for the datasource. If not specified, 1 will be used (optional).\n   * @type {number}\n   * @default 1\n   */\n  startBlock?: number;\n  /**\n   * The ending block number for the datasource (optional).\n   * @type {number}\n   */\n  endBlock?: number;\n  /**\n   * The mapping associated with the datasource.\n   * This contains the handlers.\n   * @type {M}\n   */\n  mapping: M;\n}\n\nexport interface BaseCustomDataSource<H extends BaseHandler = BaseHandler, T extends BaseMapping<H> = BaseMapping<H>>\n  extends BaseDataSource<H, T>,\n    BaseAssetsDataSource {\n  /**\n   * The processor used for the custom datasource.\n   * @type {Processor<O>}\n   */\n  processor: Processor;\n}\n\nexport interface BaseAssetsDataSource {\n  /**\n   * A map of custom datasource assets. These typically include ABIs or other files used to decode data.\n   * @type {Map<string, FileReference>}\n   * @example\n   * assets: new Map([['erc20', './abis/erc20.json']])\n   */\n  assets?: Map<string, FileReference>;\n}\n\nexport interface BaseMapping<T extends BaseHandler> extends FileReference {\n  /**\n   * An array of handlers associated with the mapping.\n   * @type {T[]}\n   */\n  handlers: T[];\n}\n\nexport interface BaseHandler<T = any, K extends string = string> {\n  kind: K;\n  /**\n   * The name of your handler function. This must be defined and exported from your code.\n   * @type {string}\n   * @example\n   * handler: 'handleBlock'\n   */\n  handler: string;\n  /**\n   * The filter for the handler. The handler kind will determine the possible filters (optional).\n   */\n  filter?: T;\n}\n\nexport interface TemplateBase {\n  /**\n   * The name of the template. This must be unique.\n   * */\n  name: string;\n}\n\nexport type BaseTemplateDataSource<DS extends BaseDataSource = BaseDataSource> = Omit<DS, 'startBlock' | 'endBlock'> &\n  TemplateBase;\n\nexport interface ProjectManifestBaseImplInterface<\n  D extends BaseDeploymentV1_0_0Interface = BaseDeploymentV1_0_0Interface,\n> {\n  deployment: D;\n}\n\nexport interface BaseDeploymentV1_0_0Interface {\n  specVersion: string;\n  schema: FileReference;\n  parent?: ParentProject;\n  toYaml(): string;\n}\n"]}