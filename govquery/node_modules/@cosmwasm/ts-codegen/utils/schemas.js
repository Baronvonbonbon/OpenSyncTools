"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findAndParseTypes = exports.findExecuteMsg = exports.findQueryMsg = exports.readSchemas = exports.findSchemaFiles = void 0;
const json_schema_to_typescript_1 = require("@pyramation/json-schema-to-typescript");
const fs_1 = require("fs");
const glob_1 = require("glob");
const cleanse_1 = require("./cleanse");
const parse_1 = require("./parse");
/**
 * Takes a schema directory and returns a list of relevant file paths
 */
const findSchemaFiles = async (schemaDir) => {
    const files = (0, glob_1.globSync)(schemaDir + '/**/*.json')
        .filter((file) => !file.includes('/raw/')) // raw JSON Schema files that are also included in the main <contract_name>.json
        .filter((file) => !file.includes('/cw_schema/')) // sub-folder for the new schema format for CosmWasm 3+
        .sort();
    return files;
};
exports.findSchemaFiles = findSchemaFiles;
const readSchemas = async ({ schemaDir, clean = true, }) => {
    const fn = clean
        ? cleanse_1.cleanse
        : (schema) => schema;
    const files = (await (0, exports.findSchemaFiles)(schemaDir)).map((path) => (0, fs_1.readFileSync)(path, 'utf-8'));
    if (files.length > 1) {
        // legacy
        // TODO add console.warn here
        console.warn('Found a multiple schema files. This mode will be removed in the next major version. Please migrate the schemas that contain a single <contract_name>.json IDL file (CosmWasm 1.1+).');
        const schemas = files.map((file) => JSON.parse(file));
        return {
            schemas: fn(schemas),
        };
    }
    if (files.length === 0) {
        throw new Error('Error [too few files]: requires one schema file per contract');
    }
    if (files.length !== 1) {
        throw new Error('Error [too many files]: CosmWasm v1.1 schemas supports one file');
    }
    const idlObject = JSON.parse(files[0]);
    const { 
    // contract_name,
    // contract_version,
    idl_version, responses, instantiate, execute, query, migrate, sudo, } = idlObject;
    if (typeof idl_version !== 'string') {
        // legacy
        // fall back to a single JSON Schema file
        console.warn('Found a single schema file with missing idl_version. This mode will be removed in the next major version. Please migrate the schemas that contain a single <contract_name>.json IDL file (CosmWasm 1.1+).');
        const schema = JSON.parse(files[0]);
        return {
            schemas: fn([schema]),
        };
    }
    // TODO use contract_name, etc.
    const idl = {
        instantiate,
        execute,
        query,
        migrate,
        sudo,
    };
    return {
        schemas: [
            ...Object.values(fn(idl)).filter(Boolean),
            ...Object.values(fn({ ...responses })).filter(Boolean),
        ],
        responses,
        idlObject,
    };
};
exports.readSchemas = readSchemas;
const findQueryMsg = (schemas) => {
    const queryMsg = schemas.find((schema) => schema.title === 'QueryMsg');
    return queryMsg;
};
exports.findQueryMsg = findQueryMsg;
const findExecuteMsg = (schemas) => {
    const executeMsg = schemas.find((schema) => schema.title.startsWith('ExecuteMsg'));
    return executeMsg;
};
exports.findExecuteMsg = findExecuteMsg;
const findAndParseTypes = async (schemas) => {
    const Types = schemas;
    const allTypes = [];
    for (const typ in Types) {
        if (Types[typ].definitions) {
            for (const key of Object.keys(Types[typ].definitions)) {
                // set title
                Types[typ].definitions[key].title = key;
            }
        }
        const result = await (0, json_schema_to_typescript_1.compile)(Types[typ], Types[typ].title);
        allTypes.push(result);
    }
    const typeHash = (0, parse_1.parser)(allTypes);
    return typeHash;
};
exports.findAndParseTypes = findAndParseTypes;
