"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRelativePath = exports.getImportStatements = exports.convertUtilsToImportList = exports.convertUtil = exports.UTIL_HELPERS = exports.UTILS = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var t = _interopRequireWildcard(require("@babel/types"));

var _utils = require("../utils");

var _path = require("path");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var makeReactQuerySwitch = function makeReactQuerySwitch(varName) {
  return function (context) {
    switch (context.options.reactQuery.version) {
      case 'v4':
        return {
          type: 'import',
          path: '@tanstack/react-query',
          name: varName
        };

      case 'v3':
      default:
        return {
          type: 'import',
          path: 'react-query',
          name: varName
        };
    }
  };
};

var UTILS = {
  selectorFamily: 'recoil',
  MsgExecuteContract: 'cosmjs-types/cosmwasm/wasm/v1/tx',
  MsgExecuteContractEncodeObject: '@cosmjs/cosmwasm-stargate',
  Coin: '@cosmjs/amino',
  toUtf8: '@cosmjs/encoding',
  StdFee: '@cosmjs/amino',
  CosmWasmClient: '@cosmjs/cosmwasm-stargate',
  ExecuteResult: '@cosmjs/cosmwasm-stargate',
  SigningCosmWasmClient: '@cosmjs/cosmwasm-stargate',
  // react-query
  useQuery: makeReactQuerySwitch('useQuery'),
  UseQueryOptions: makeReactQuerySwitch('UseQueryOptions'),
  useMutation: makeReactQuerySwitch('useMutation'),
  UseMutationOptions: makeReactQuerySwitch('UseMutationOptions')
};
exports.UTILS = UTILS;
var UTIL_HELPERS = ['__contractContextBase__'];
exports.UTIL_HELPERS = UTIL_HELPERS;

var convertUtilsToImportList = function convertUtilsToImportList(context, utils, registeredUtils) {
  return utils.map(function (util) {
    var result = null;

    if (registeredUtils) {
      result = convertUtil(context, util, registeredUtils);

      if (result) {
        return result;
      }
    }

    result = convertUtil(context, util, UTILS);

    if (result) {
      return result;
    }

    throw new Error("missing Util! ::[".concat(util, "]"));
  });
};

exports.convertUtilsToImportList = convertUtilsToImportList;

var convertUtil = function convertUtil(context, util, registeredUtils) {
  if (!registeredUtils.hasOwnProperty(util)) return null;

  if (typeof registeredUtils[util] === 'string') {
    return {
      type: 'import',
      path: registeredUtils[util],
      name: util
    };
  } else if (typeof registeredUtils[util] === 'function') {
    return registeredUtils[util](context);
  } else {
    return registeredUtils[util];
  }
}; // __helpers__


exports.convertUtil = convertUtil;

var getImportStatements = function getImportStatements(list, filepath) {
  // swap helpers with helpers file...
  var modifiedImports = list.map(function (imp) {
    if (filepath && UTIL_HELPERS.includes(imp.path)) {
      var name = imp.path.replace(/__/g, '');
      return _objectSpread(_objectSpread({}, imp), {}, {
        path: getRelativePath(filepath, "./".concat(name))
      });
    }

    return imp;
  });
  var imports = modifiedImports.reduce(function (m, obj) {
    m[obj.path] = m[obj.path] || [];
    var exists = m[obj.path].find(function (el) {
      return el.type === obj.type && el.path === obj.path && el.name === obj.name;
    }); // MARKED AS NOT DRY [google.protobuf names]
    // TODO some have google.protobuf.Any shows up... figure out the better way to handle this

    if (/\./.test(obj.name)) {
      obj.name = obj.name.split('.')[obj.name.split('.').length - 1];
    }

    if (!exists) {
      m[obj.path].push(obj);
    }

    return m;
  }, {});
  return Object.entries(imports).reduce(function (m, _ref) {
    var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
        importPath = _ref2[0],
        imports = _ref2[1];

    var defaultImports = imports.filter(function (a) {
      return a.type === 'default';
    });

    if (defaultImports.length) {
      if (defaultImports.length > 1) throw new Error('more than one default name NOT allowed.');
      m.push(t.importDeclaration([t.importDefaultSpecifier(t.identifier(defaultImports[0].name))], t.stringLiteral(defaultImports[0].path)));
    }

    var namedImports = imports.filter(function (a) {
      return a.type === 'import' && (!a.importAs || a.name === a.importAs);
    });

    if (namedImports.length) {
      m.push((0, _utils.importStmt)(namedImports.map(function (i) {
        return i.name;
      }), namedImports[0].path));
    }

    var aliasNamedImports = imports.filter(function (a) {
      return a.type === 'import' && a.importAs && a.name !== a.importAs;
    });
    aliasNamedImports.forEach(function (imp) {
      m.push((0, _utils.importAs)(imp.name, imp.importAs, imp.path));
    });
    var namespaced = imports.filter(function (a) {
      return a.type === 'namespace';
    });

    if (namespaced.length) {
      if (namespaced.length > 1) throw new Error('more than one namespaced name NOT allowed.');
      m.push(t.importDeclaration([t.importNamespaceSpecifier(t.identifier(namespaced[0].name))], t.stringLiteral(namespaced[0].path)));
    }

    return m;
  }, []);
};

exports.getImportStatements = getImportStatements;

var getRelativePath = function getRelativePath(f1, f2) {
  var rel = (0, _path.relative)((0, _path.dirname)(f1), f2);
  var importPath = rel.replace((0, _path.extname)(rel), '');
  if (!/^\./.test(importPath)) importPath = "./".concat(importPath);
  return importPath;
};

exports.getRelativePath = getRelativePath;