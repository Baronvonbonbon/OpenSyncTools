"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMsgBuilderClass = void 0;

var t = _interopRequireWildcard(require("@babel/types"));

var _case = require("case");

var _utils = require("../utils");

var _types2 = require("../utils/types");

var _client = require("../client/client");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var createMsgBuilderClass = function createMsgBuilderClass(context, className, msg) {
  var staticMethods = (0, _utils.getMessageProperties)(msg).map(function (schema) {
    return createStaticExecMethodMsgBuilder(context, schema, msg.title);
  }); // const blockStmt = bindings;

  return t.exportNamedDeclaration((0, _utils.abstractClassDeclaration)(className, staticMethods, [], null));
};
/**
 * CamelCasedProperties<Extract<ExecuteMsg, { exec_on_module: unknown }>['exec_on_module']>
 */


exports.createMsgBuilderClass = createMsgBuilderClass;

function createExtractTypeAnnotation(underscoreName, msgTitle) {
  return t.tsTypeAnnotation(t.tsTypeReference(t.identifier('CamelCasedProperties'), t.tsTypeParameterInstantiation([t.tsIndexedAccessType(t.tsTypeReference(t.identifier('Extract'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(msgTitle)), t.tsTypeLiteral([t.tsPropertySignature(t.identifier(underscoreName), t.tsTypeAnnotation(t.tsUnknownKeyword()))])])), t.tsLiteralType(t.stringLiteral(underscoreName)))])));
}

var createStaticExecMethodMsgBuilder = function createStaticExecMethodMsgBuilder(context, jsonschema, msgTitle) {
  var underscoreName = Object.keys(jsonschema.properties)[0];
  var methodName = (0, _case.camel)(underscoreName);
  var param = (0, _types2.createTypedObjectParams)(context, jsonschema.properties[underscoreName]);
  var args = (0, _client.getWasmMethodArgs)(context, jsonschema.properties[underscoreName]); // what the underscore named property in the message is assigned to

  var actionValue;

  if ((param === null || param === void 0 ? void 0 : param.type) === 'Identifier') {
    actionValue = t.identifier(param.name);
  } else {
    actionValue = t.tsAsExpression(t.objectExpression(args), t.tsTypeReference(t.identifier('const')));
  } // TODO: this is a hack to get the type annotation to work
  // all type annotations in the future should be the extracted and camelized type


  if (param && param.typeAnnotation.type === 'TSTypeAnnotation' && param.typeAnnotation.typeAnnotation.type === 'TSTypeLiteral') {
    param.typeAnnotation = createExtractTypeAnnotation(underscoreName, msgTitle);
  }

  return t.classProperty(t.identifier(methodName), (0, _utils.arrowFunctionExpression)( // params
  param ? [// props
  param] : [], // body
  t.blockStatement([t.returnStatement(t.objectExpression([t.objectProperty(t.identifier(underscoreName), actionValue)]))]), // return type
  t.tsTypeAnnotation(t.tsTypeReference(t.identifier(msgTitle))), false), null, null, false, // static
  true);
};